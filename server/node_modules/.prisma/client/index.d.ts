
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  email: string
  name: string | null
  username: string
  updatedAt: Date
  createdAt: Date
}

/**
 * Model Request
 * 
 */
export type Request = {
  id: number
  type: RequestType
  state: RequestState
  recipientId: number
  createdById: number
  createdAt: Date
}

/**
 * Model Alert
 * 
 */
export type Alert = {
  id: number
  type: AlertType
  createdById: number
  createdAt: Date
  chatId: number | null
  requestId: number | null
}

/**
 * Model Member
 * 
 */
export type Member = {
  id: number
  userId: number
  chatId: number
  role: Role
  addedById: number
  createdAt: Date
  removedAt: Date | null
  removedById: number | null
}

/**
 * Model Chat
 * 
 */
export type Chat = {
  id: number
  type: ChatType
  name: string | null
  description: string | null
  createdById: number
  updatedAt: Date
  createdAt: Date
  deletedAt: Date | null
}

/**
 * Model Event
 * 
 */
export type Event = {
  id: number
  type: EventType
  chatId: number
  createdById: number
  updatedAt: Date
  createdAt: Date
  deletedAt: Date | null
}

/**
 * Model Message
 * 
 */
export type Message = {
  eventId: number
  content: string
}

/**
 * Model ChatUpdate
 * 
 */
export type ChatUpdate = {
  eventId: number
  type: ChatUpdateType
  nameBefore: string | null
  nameAfter: string | null
  descriptionBefore: string | null
  descriptionAfter: string | null
  newRole: Role | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const AlertType: {
  FRIEND_DELETED: 'FRIEND_DELETED',
  REQUEST_ACCEPTED: 'REQUEST_ACCEPTED',
  REQUEST_DECLINED: 'REQUEST_DECLINED',
  CHAT_ACCESS_REVOKED: 'CHAT_ACCESS_REVOKED',
  CHAT_ACCESS_GRANTED: 'CHAT_ACCESS_GRANTED',
  CHAT_ROLE_CHANGED: 'CHAT_ROLE_CHANGED',
  CHAT_DELETED: 'CHAT_DELETED'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const ChatType: {
  DIRECT_MESSAGE: 'DIRECT_MESSAGE',
  GROUP: 'GROUP'
};

export type ChatType = (typeof ChatType)[keyof typeof ChatType]


export const ChatUpdateType: {
  MEMBERS_ADDED: 'MEMBERS_ADDED',
  MEMBERS_REMOVED: 'MEMBERS_REMOVED',
  ROLE_CHANGED: 'ROLE_CHANGED',
  NAME_UPDATED: 'NAME_UPDATED',
  DESCRIPTION_UPDATED: 'DESCRIPTION_UPDATED'
};

export type ChatUpdateType = (typeof ChatUpdateType)[keyof typeof ChatUpdateType]


export const EventType: {
  MESSAGE: 'MESSAGE',
  CHAT_UPDATE: 'CHAT_UPDATE'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const RequestState: {
  SENT: 'SENT',
  CANCELLED: 'CANCELLED',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED'
};

export type RequestState = (typeof RequestState)[keyof typeof RequestState]


export const RequestType: {
  FRIEND_REQUEST: 'FRIEND_REQUEST'
};

export type RequestType = (typeof RequestType)[keyof typeof RequestType]


export const Role: {
  BASIC: 'BASIC',
  ADMIN: 'ADMIN',
  OWNER: 'OWNER'
};

export type Role = (typeof Role)[keyof typeof Role]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.request`: Exposes CRUD operations for the **Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.request.findMany()
    * ```
    */
  get request(): Prisma.RequestDelegate<GlobalReject>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<GlobalReject>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<GlobalReject>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<GlobalReject>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.chatUpdate`: Exposes CRUD operations for the **ChatUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatUpdates
    * const chatUpdates = await prisma.chatUpdate.findMany()
    * ```
    */
  get chatUpdate(): Prisma.ChatUpdateDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.11.0
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Request: 'Request',
    Alert: 'Alert',
    Member: 'Member',
    Chat: 'Chat',
    Event: 'Event',
    Message: 'Message',
    ChatUpdate: 'ChatUpdate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    friends: number
    friendsOf: number
    likedMessages: number
    creatorOfChats: number
    alerts: number
    alertsSent: number
    requests: number
    requestsSent: number
    eventsCreated: number
    memberOfChats: number
    membersAddedToChat: number
    membersRemoved: number
  }

  export type UserCountOutputTypeSelect = {
    friends?: boolean
    friendsOf?: boolean
    likedMessages?: boolean
    creatorOfChats?: boolean
    alerts?: boolean
    alertsSent?: boolean
    requests?: boolean
    requestsSent?: boolean
    eventsCreated?: boolean
    memberOfChats?: boolean
    membersAddedToChat?: boolean
    membersRemoved?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type AlertCountOutputType
   */


  export type AlertCountOutputType = {
    recipients: number
  }

  export type AlertCountOutputTypeSelect = {
    recipients?: boolean
  }

  export type AlertCountOutputTypeGetPayload<S extends boolean | null | undefined | AlertCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AlertCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AlertCountOutputTypeArgs)
    ? AlertCountOutputType 
    : S extends { select: any } & (AlertCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AlertCountOutputType ? AlertCountOutputType[P] : never
  } 
      : AlertCountOutputType




  // Custom InputTypes

  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AlertCountOutputType
     */
    select?: AlertCountOutputTypeSelect | null
  }



  /**
   * Count Type MemberCountOutputType
   */


  export type MemberCountOutputType = {
    chatUpdates: number
  }

  export type MemberCountOutputTypeSelect = {
    chatUpdates?: boolean
  }

  export type MemberCountOutputTypeGetPayload<S extends boolean | null | undefined | MemberCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MemberCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MemberCountOutputTypeArgs)
    ? MemberCountOutputType 
    : S extends { select: any } & (MemberCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MemberCountOutputType ? MemberCountOutputType[P] : never
  } 
      : MemberCountOutputType




  // Custom InputTypes

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect | null
  }



  /**
   * Count Type ChatCountOutputType
   */


  export type ChatCountOutputType = {
    members: number
    event: number
    alerts: number
  }

  export type ChatCountOutputTypeSelect = {
    members?: boolean
    event?: boolean
    alerts?: boolean
  }

  export type ChatCountOutputTypeGetPayload<S extends boolean | null | undefined | ChatCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChatCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChatCountOutputTypeArgs)
    ? ChatCountOutputType 
    : S extends { select: any } & (ChatCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChatCountOutputType ? ChatCountOutputType[P] : never
  } 
      : ChatCountOutputType




  // Custom InputTypes

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect | null
  }



  /**
   * Count Type MessageCountOutputType
   */


  export type MessageCountOutputType = {
    likedBy: number
  }

  export type MessageCountOutputTypeSelect = {
    likedBy?: boolean
  }

  export type MessageCountOutputTypeGetPayload<S extends boolean | null | undefined | MessageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MessageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MessageCountOutputTypeArgs)
    ? MessageCountOutputType 
    : S extends { select: any } & (MessageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MessageCountOutputType ? MessageCountOutputType[P] : never
  } 
      : MessageCountOutputType




  // Custom InputTypes

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect | null
  }



  /**
   * Count Type ChatUpdateCountOutputType
   */


  export type ChatUpdateCountOutputType = {
    members: number
  }

  export type ChatUpdateCountOutputTypeSelect = {
    members?: boolean
  }

  export type ChatUpdateCountOutputTypeGetPayload<S extends boolean | null | undefined | ChatUpdateCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChatUpdateCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ChatUpdateCountOutputTypeArgs)
    ? ChatUpdateCountOutputType 
    : S extends { select: any } & (ChatUpdateCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ChatUpdateCountOutputType ? ChatUpdateCountOutputType[P] : never
  } 
      : ChatUpdateCountOutputType




  // Custom InputTypes

  /**
   * ChatUpdateCountOutputType without action
   */
  export type ChatUpdateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdateCountOutputType
     */
    select?: ChatUpdateCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    username: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    username: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    username: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    username?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    username?: true
    updatedAt?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    username?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string | null
    username: string
    updatedAt: Date
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    email?: boolean
    name?: boolean
    username?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    friends?: boolean | User$friendsArgs
    friendsOf?: boolean | User$friendsOfArgs
    likedMessages?: boolean | User$likedMessagesArgs
    creatorOfChats?: boolean | User$creatorOfChatsArgs
    alerts?: boolean | User$alertsArgs
    alertsSent?: boolean | User$alertsSentArgs
    requests?: boolean | User$requestsArgs
    requestsSent?: boolean | User$requestsSentArgs
    eventsCreated?: boolean | User$eventsCreatedArgs
    memberOfChats?: boolean | User$memberOfChatsArgs
    membersAddedToChat?: boolean | User$membersAddedToChatArgs
    membersRemoved?: boolean | User$membersRemovedArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    friends?: boolean | User$friendsArgs
    friendsOf?: boolean | User$friendsOfArgs
    likedMessages?: boolean | User$likedMessagesArgs
    creatorOfChats?: boolean | User$creatorOfChatsArgs
    alerts?: boolean | User$alertsArgs
    alertsSent?: boolean | User$alertsSentArgs
    requests?: boolean | User$requestsArgs
    requestsSent?: boolean | User$requestsSentArgs
    eventsCreated?: boolean | User$eventsCreatedArgs
    memberOfChats?: boolean | User$memberOfChatsArgs
    membersAddedToChat?: boolean | User$membersAddedToChatArgs
    membersRemoved?: boolean | User$membersRemovedArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'friends' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'friendsOf' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'likedMessages' ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'creatorOfChats' ? Array < ChatGetPayload<S['include'][P]>>  :
        P extends 'alerts' ? Array < AlertGetPayload<S['include'][P]>>  :
        P extends 'alertsSent' ? Array < AlertGetPayload<S['include'][P]>>  :
        P extends 'requests' ? Array < RequestGetPayload<S['include'][P]>>  :
        P extends 'requestsSent' ? Array < RequestGetPayload<S['include'][P]>>  :
        P extends 'eventsCreated' ? Array < EventGetPayload<S['include'][P]>>  :
        P extends 'memberOfChats' ? Array < MemberGetPayload<S['include'][P]>>  :
        P extends 'membersAddedToChat' ? Array < MemberGetPayload<S['include'][P]>>  :
        P extends 'membersRemoved' ? Array < MemberGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'friends' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'friendsOf' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'likedMessages' ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'creatorOfChats' ? Array < ChatGetPayload<S['select'][P]>>  :
        P extends 'alerts' ? Array < AlertGetPayload<S['select'][P]>>  :
        P extends 'alertsSent' ? Array < AlertGetPayload<S['select'][P]>>  :
        P extends 'requests' ? Array < RequestGetPayload<S['select'][P]>>  :
        P extends 'requestsSent' ? Array < RequestGetPayload<S['select'][P]>>  :
        P extends 'eventsCreated' ? Array < EventGetPayload<S['select'][P]>>  :
        P extends 'memberOfChats' ? Array < MemberGetPayload<S['select'][P]>>  :
        P extends 'membersAddedToChat' ? Array < MemberGetPayload<S['select'][P]>>  :
        P extends 'membersRemoved' ? Array < MemberGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    friends<T extends User$friendsArgs= {}>(args?: Subset<T, User$friendsArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    friendsOf<T extends User$friendsOfArgs= {}>(args?: Subset<T, User$friendsOfArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    likedMessages<T extends User$likedMessagesArgs= {}>(args?: Subset<T, User$likedMessagesArgs>): Prisma.PrismaPromise<Array<MessageGetPayload<T>>| Null>;

    creatorOfChats<T extends User$creatorOfChatsArgs= {}>(args?: Subset<T, User$creatorOfChatsArgs>): Prisma.PrismaPromise<Array<ChatGetPayload<T>>| Null>;

    alerts<T extends User$alertsArgs= {}>(args?: Subset<T, User$alertsArgs>): Prisma.PrismaPromise<Array<AlertGetPayload<T>>| Null>;

    alertsSent<T extends User$alertsSentArgs= {}>(args?: Subset<T, User$alertsSentArgs>): Prisma.PrismaPromise<Array<AlertGetPayload<T>>| Null>;

    requests<T extends User$requestsArgs= {}>(args?: Subset<T, User$requestsArgs>): Prisma.PrismaPromise<Array<RequestGetPayload<T>>| Null>;

    requestsSent<T extends User$requestsSentArgs= {}>(args?: Subset<T, User$requestsSentArgs>): Prisma.PrismaPromise<Array<RequestGetPayload<T>>| Null>;

    eventsCreated<T extends User$eventsCreatedArgs= {}>(args?: Subset<T, User$eventsCreatedArgs>): Prisma.PrismaPromise<Array<EventGetPayload<T>>| Null>;

    memberOfChats<T extends User$memberOfChatsArgs= {}>(args?: Subset<T, User$memberOfChatsArgs>): Prisma.PrismaPromise<Array<MemberGetPayload<T>>| Null>;

    membersAddedToChat<T extends User$membersAddedToChatArgs= {}>(args?: Subset<T, User$membersAddedToChatArgs>): Prisma.PrismaPromise<Array<MemberGetPayload<T>>| Null>;

    membersRemoved<T extends User$membersRemovedArgs= {}>(args?: Subset<T, User$membersRemovedArgs>): Prisma.PrismaPromise<Array<MemberGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.friends
   */
  export type User$friendsArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User.friendsOf
   */
  export type User$friendsOfArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User.likedMessages
   */
  export type User$likedMessagesArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * User.creatorOfChats
   */
  export type User$creatorOfChatsArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    where?: ChatWhereInput
    orderBy?: Enumerable<ChatOrderByWithRelationInput>
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChatScalarFieldEnum>
  }


  /**
   * User.alerts
   */
  export type User$alertsArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * User.alertsSent
   */
  export type User$alertsSentArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * User.requests
   */
  export type User$requestsArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    where?: RequestWhereInput
    orderBy?: Enumerable<RequestOrderByWithRelationInput>
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * User.requestsSent
   */
  export type User$requestsSentArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    where?: RequestWhereInput
    orderBy?: Enumerable<RequestOrderByWithRelationInput>
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * User.eventsCreated
   */
  export type User$eventsCreatedArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * User.memberOfChats
   */
  export type User$memberOfChatsArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    where?: MemberWhereInput
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * User.membersAddedToChat
   */
  export type User$membersAddedToChatArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    where?: MemberWhereInput
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * User.membersRemoved
   */
  export type User$membersRemovedArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    where?: MemberWhereInput
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Request
   */


  export type AggregateRequest = {
    _count: RequestCountAggregateOutputType | null
    _avg: RequestAvgAggregateOutputType | null
    _sum: RequestSumAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  export type RequestAvgAggregateOutputType = {
    id: number | null
    recipientId: number | null
    createdById: number | null
  }

  export type RequestSumAggregateOutputType = {
    id: number | null
    recipientId: number | null
    createdById: number | null
  }

  export type RequestMinAggregateOutputType = {
    id: number | null
    type: RequestType | null
    state: RequestState | null
    recipientId: number | null
    createdById: number | null
    createdAt: Date | null
  }

  export type RequestMaxAggregateOutputType = {
    id: number | null
    type: RequestType | null
    state: RequestState | null
    recipientId: number | null
    createdById: number | null
    createdAt: Date | null
  }

  export type RequestCountAggregateOutputType = {
    id: number
    type: number
    state: number
    recipientId: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type RequestAvgAggregateInputType = {
    id?: true
    recipientId?: true
    createdById?: true
  }

  export type RequestSumAggregateInputType = {
    id?: true
    recipientId?: true
    createdById?: true
  }

  export type RequestMinAggregateInputType = {
    id?: true
    type?: true
    state?: true
    recipientId?: true
    createdById?: true
    createdAt?: true
  }

  export type RequestMaxAggregateInputType = {
    id?: true
    type?: true
    state?: true
    recipientId?: true
    createdById?: true
    createdAt?: true
  }

  export type RequestCountAggregateInputType = {
    id?: true
    type?: true
    state?: true
    recipientId?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type RequestAggregateArgs = {
    /**
     * Filter which Request to aggregate.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: Enumerable<RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requests
    **/
    _count?: true | RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMaxAggregateInputType
  }

  export type GetRequestAggregateType<T extends RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest[P]>
      : GetScalarType<T[P], AggregateRequest[P]>
  }




  export type RequestGroupByArgs = {
    where?: RequestWhereInput
    orderBy?: Enumerable<RequestOrderByWithAggregationInput>
    by: RequestScalarFieldEnum[]
    having?: RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCountAggregateInputType | true
    _avg?: RequestAvgAggregateInputType
    _sum?: RequestSumAggregateInputType
    _min?: RequestMinAggregateInputType
    _max?: RequestMaxAggregateInputType
  }


  export type RequestGroupByOutputType = {
    id: number
    type: RequestType
    state: RequestState
    recipientId: number
    createdById: number
    createdAt: Date
    _count: RequestCountAggregateOutputType | null
    _avg: RequestAvgAggregateOutputType | null
    _sum: RequestSumAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  type GetRequestGroupByPayload<T extends RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestGroupByOutputType[P]>
            : GetScalarType<T[P], RequestGroupByOutputType[P]>
        }
      >
    >


  export type RequestSelect = {
    id?: boolean
    type?: boolean
    state?: boolean
    recipientId?: boolean
    createdById?: boolean
    createdAt?: boolean
    recipient?: boolean | UserArgs
    createdBy?: boolean | UserArgs
    alert?: boolean | AlertArgs
  }


  export type RequestInclude = {
    recipient?: boolean | UserArgs
    createdBy?: boolean | UserArgs
    alert?: boolean | AlertArgs
  }

  export type RequestGetPayload<S extends boolean | null | undefined | RequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Request :
    S extends undefined ? never :
    S extends { include: any } & (RequestArgs | RequestFindManyArgs)
    ? Request  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'recipient' ? UserGetPayload<S['include'][P]> :
        P extends 'createdBy' ? UserGetPayload<S['include'][P]> :
        P extends 'alert' ? AlertGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (RequestArgs | RequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'recipient' ? UserGetPayload<S['select'][P]> :
        P extends 'createdBy' ? UserGetPayload<S['select'][P]> :
        P extends 'alert' ? AlertGetPayload<S['select'][P]> | null :  P extends keyof Request ? Request[P] : never
  } 
      : Request


  type RequestCountArgs = 
    Omit<RequestFindManyArgs, 'select' | 'include'> & {
      select?: RequestCountAggregateInputType | true
    }

  export interface RequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Request that matches the filter.
     * @param {RequestFindUniqueArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Request'> extends True ? Prisma__RequestClient<RequestGetPayload<T>> : Prisma__RequestClient<RequestGetPayload<T> | null, null>

    /**
     * Find one Request that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RequestFindUniqueOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RequestFindUniqueOrThrowArgs>
    ): Prisma__RequestClient<RequestGetPayload<T>>

    /**
     * Find the first Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Request'> extends True ? Prisma__RequestClient<RequestGetPayload<T>> : Prisma__RequestClient<RequestGetPayload<T> | null, null>

    /**
     * Find the first Request that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RequestFindFirstOrThrowArgs>
    ): Prisma__RequestClient<RequestGetPayload<T>>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.request.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestWithIdOnly = await prisma.request.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RequestFindManyArgs>(
      args?: SelectSubset<T, RequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<RequestGetPayload<T>>>

    /**
     * Create a Request.
     * @param {RequestCreateArgs} args - Arguments to create a Request.
     * @example
     * // Create one Request
     * const Request = await prisma.request.create({
     *   data: {
     *     // ... data to create a Request
     *   }
     * })
     * 
    **/
    create<T extends RequestCreateArgs>(
      args: SelectSubset<T, RequestCreateArgs>
    ): Prisma__RequestClient<RequestGetPayload<T>>

    /**
     * Create many Requests.
     *     @param {RequestCreateManyArgs} args - Arguments to create many Requests.
     *     @example
     *     // Create many Requests
     *     const request = await prisma.request.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestCreateManyArgs>(
      args?: SelectSubset<T, RequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Request.
     * @param {RequestDeleteArgs} args - Arguments to delete one Request.
     * @example
     * // Delete one Request
     * const Request = await prisma.request.delete({
     *   where: {
     *     // ... filter to delete one Request
     *   }
     * })
     * 
    **/
    delete<T extends RequestDeleteArgs>(
      args: SelectSubset<T, RequestDeleteArgs>
    ): Prisma__RequestClient<RequestGetPayload<T>>

    /**
     * Update one Request.
     * @param {RequestUpdateArgs} args - Arguments to update one Request.
     * @example
     * // Update one Request
     * const request = await prisma.request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestUpdateArgs>(
      args: SelectSubset<T, RequestUpdateArgs>
    ): Prisma__RequestClient<RequestGetPayload<T>>

    /**
     * Delete zero or more Requests.
     * @param {RequestDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestDeleteManyArgs>(
      args?: SelectSubset<T, RequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestUpdateManyArgs>(
      args: SelectSubset<T, RequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Request.
     * @param {RequestUpsertArgs} args - Arguments to update or create a Request.
     * @example
     * // Update or create a Request
     * const request = await prisma.request.upsert({
     *   create: {
     *     // ... data to create a Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request we want to update
     *   }
     * })
    **/
    upsert<T extends RequestUpsertArgs>(
      args: SelectSubset<T, RequestUpsertArgs>
    ): Prisma__RequestClient<RequestGetPayload<T>>

    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.request.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends RequestCountArgs>(
      args?: Subset<T, RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregateArgs>(args: Subset<T, RequestAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregateType<T>>

    /**
     * Group by Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestGroupByArgs['orderBy'] }
        : { orderBy?: RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    recipient<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    createdBy<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    alert<T extends AlertArgs= {}>(args?: Subset<T, AlertArgs>): Prisma__AlertClient<AlertGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Request base type for findUnique actions
   */
  export type RequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }

  /**
   * Request findUnique
   */
  export interface RequestFindUniqueArgs extends RequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Request findUniqueOrThrow
   */
  export type RequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }


  /**
   * Request base type for findFirst actions
   */
  export type RequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: Enumerable<RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: Enumerable<RequestScalarFieldEnum>
  }

  /**
   * Request findFirst
   */
  export interface RequestFindFirstArgs extends RequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Request findFirstOrThrow
   */
  export type RequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: Enumerable<RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * Request findMany
   */
  export type RequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: Enumerable<RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    distinct?: Enumerable<RequestScalarFieldEnum>
  }


  /**
   * Request create
   */
  export type RequestCreateArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * The data needed to create a Request.
     */
    data: XOR<RequestCreateInput, RequestUncheckedCreateInput>
  }


  /**
   * Request createMany
   */
  export type RequestCreateManyArgs = {
    /**
     * The data used to create many Requests.
     */
    data: Enumerable<RequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Request update
   */
  export type RequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * The data needed to update a Request.
     */
    data: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
    /**
     * Choose, which Request to update.
     */
    where: RequestWhereUniqueInput
  }


  /**
   * Request updateMany
   */
  export type RequestUpdateManyArgs = {
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
  }


  /**
   * Request upsert
   */
  export type RequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * The filter to search for the Request to update in case it exists.
     */
    where: RequestWhereUniqueInput
    /**
     * In case the Request found by the `where` argument doesn't exist, create a new Request with this data.
     */
    create: XOR<RequestCreateInput, RequestUncheckedCreateInput>
    /**
     * In case the Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
  }


  /**
   * Request delete
   */
  export type RequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
    /**
     * Filter which Request to delete.
     */
    where: RequestWhereUniqueInput
  }


  /**
   * Request deleteMany
   */
  export type RequestDeleteManyArgs = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestWhereInput
  }


  /**
   * Request without action
   */
  export type RequestArgs = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude | null
  }



  /**
   * Model Alert
   */


  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    chatId: number | null
    requestId: number | null
  }

  export type AlertSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    chatId: number | null
    requestId: number | null
  }

  export type AlertMinAggregateOutputType = {
    id: number | null
    type: AlertType | null
    createdById: number | null
    createdAt: Date | null
    chatId: number | null
    requestId: number | null
  }

  export type AlertMaxAggregateOutputType = {
    id: number | null
    type: AlertType | null
    createdById: number | null
    createdAt: Date | null
    chatId: number | null
    requestId: number | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    type: number
    createdById: number
    createdAt: number
    chatId: number
    requestId: number
    _all: number
  }


  export type AlertAvgAggregateInputType = {
    id?: true
    createdById?: true
    chatId?: true
    requestId?: true
  }

  export type AlertSumAggregateInputType = {
    id?: true
    createdById?: true
    chatId?: true
    requestId?: true
  }

  export type AlertMinAggregateInputType = {
    id?: true
    type?: true
    createdById?: true
    createdAt?: true
    chatId?: true
    requestId?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    type?: true
    createdById?: true
    createdAt?: true
    chatId?: true
    requestId?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    type?: true
    createdById?: true
    createdAt?: true
    chatId?: true
    requestId?: true
    _all?: true
  }

  export type AlertAggregateArgs = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs = {
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithAggregationInput>
    by: AlertScalarFieldEnum[]
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _avg?: AlertAvgAggregateInputType
    _sum?: AlertSumAggregateInputType
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }


  export type AlertGroupByOutputType = {
    id: number
    type: AlertType
    createdById: number
    createdAt: Date
    chatId: number | null
    requestId: number | null
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect = {
    id?: boolean
    type?: boolean
    createdById?: boolean
    createdAt?: boolean
    chatId?: boolean
    requestId?: boolean
    recipients?: boolean | Alert$recipientsArgs
    createdBy?: boolean | UserArgs
    chat?: boolean | ChatArgs
    request?: boolean | RequestArgs
    _count?: boolean | AlertCountOutputTypeArgs
  }


  export type AlertInclude = {
    recipients?: boolean | Alert$recipientsArgs
    createdBy?: boolean | UserArgs
    chat?: boolean | ChatArgs
    request?: boolean | RequestArgs
    _count?: boolean | AlertCountOutputTypeArgs
  }

  export type AlertGetPayload<S extends boolean | null | undefined | AlertArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Alert :
    S extends undefined ? never :
    S extends { include: any } & (AlertArgs | AlertFindManyArgs)
    ? Alert  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'recipients' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'createdBy' ? UserGetPayload<S['include'][P]> :
        P extends 'chat' ? ChatGetPayload<S['include'][P]> | null :
        P extends 'request' ? RequestGetPayload<S['include'][P]> | null :
        P extends '_count' ? AlertCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AlertArgs | AlertFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'recipients' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'createdBy' ? UserGetPayload<S['select'][P]> :
        P extends 'chat' ? ChatGetPayload<S['select'][P]> | null :
        P extends 'request' ? RequestGetPayload<S['select'][P]> | null :
        P extends '_count' ? AlertCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Alert ? Alert[P] : never
  } 
      : Alert


  type AlertCountArgs = 
    Omit<AlertFindManyArgs, 'select' | 'include'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlertFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlertFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alert'> extends True ? Prisma__AlertClient<AlertGetPayload<T>> : Prisma__AlertClient<AlertGetPayload<T> | null, null>

    /**
     * Find one Alert that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AlertFindUniqueOrThrowArgs>
    ): Prisma__AlertClient<AlertGetPayload<T>>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlertFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlertFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alert'> extends True ? Prisma__AlertClient<AlertGetPayload<T>> : Prisma__AlertClient<AlertGetPayload<T> | null, null>

    /**
     * Find the first Alert that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AlertFindFirstOrThrowArgs>
    ): Prisma__AlertClient<AlertGetPayload<T>>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlertFindManyArgs>(
      args?: SelectSubset<T, AlertFindManyArgs>
    ): Prisma.PrismaPromise<Array<AlertGetPayload<T>>>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
    **/
    create<T extends AlertCreateArgs>(
      args: SelectSubset<T, AlertCreateArgs>
    ): Prisma__AlertClient<AlertGetPayload<T>>

    /**
     * Create many Alerts.
     *     @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     *     @example
     *     // Create many Alerts
     *     const alert = await prisma.alert.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlertCreateManyArgs>(
      args?: SelectSubset<T, AlertCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
    **/
    delete<T extends AlertDeleteArgs>(
      args: SelectSubset<T, AlertDeleteArgs>
    ): Prisma__AlertClient<AlertGetPayload<T>>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlertUpdateArgs>(
      args: SelectSubset<T, AlertUpdateArgs>
    ): Prisma__AlertClient<AlertGetPayload<T>>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlertDeleteManyArgs>(
      args?: SelectSubset<T, AlertDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlertUpdateManyArgs>(
      args: SelectSubset<T, AlertUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
    **/
    upsert<T extends AlertUpsertArgs>(
      args: SelectSubset<T, AlertUpsertArgs>
    ): Prisma__AlertClient<AlertGetPayload<T>>

    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlertClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    recipients<T extends Alert$recipientsArgs= {}>(args?: Subset<T, Alert$recipientsArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    createdBy<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    chat<T extends ChatArgs= {}>(args?: Subset<T, ChatArgs>): Prisma__ChatClient<ChatGetPayload<T> | Null>;

    request<T extends RequestArgs= {}>(args?: Subset<T, RequestArgs>): Prisma__RequestClient<RequestGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Alert base type for findUnique actions
   */
  export type AlertFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUnique
   */
  export interface AlertFindUniqueArgs extends AlertFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert base type for findFirst actions
   */
  export type AlertFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: Enumerable<AlertScalarFieldEnum>
  }

  /**
   * Alert findFirst
   */
  export interface AlertFindFirstArgs extends AlertFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * Alert findMany
   */
  export type AlertFindManyArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * Alert create
   */
  export type AlertCreateArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }


  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs = {
    /**
     * The data used to create many Alerts.
     */
    data: Enumerable<AlertCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alert update
   */
  export type AlertUpdateArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }


  /**
   * Alert upsert
   */
  export type AlertUpsertArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }


  /**
   * Alert delete
   */
  export type AlertDeleteArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }


  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }


  /**
   * Alert.recipients
   */
  export type Alert$recipientsArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Alert without action
   */
  export type AlertArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
  }



  /**
   * Model Member
   */


  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    chatId: number | null
    addedById: number | null
    removedById: number | null
  }

  export type MemberSumAggregateOutputType = {
    id: number | null
    userId: number | null
    chatId: number | null
    addedById: number | null
    removedById: number | null
  }

  export type MemberMinAggregateOutputType = {
    id: number | null
    userId: number | null
    chatId: number | null
    role: Role | null
    addedById: number | null
    createdAt: Date | null
    removedAt: Date | null
    removedById: number | null
  }

  export type MemberMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    chatId: number | null
    role: Role | null
    addedById: number | null
    createdAt: Date | null
    removedAt: Date | null
    removedById: number | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    userId: number
    chatId: number
    role: number
    addedById: number
    createdAt: number
    removedAt: number
    removedById: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    addedById?: true
    removedById?: true
  }

  export type MemberSumAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    addedById?: true
    removedById?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    role?: true
    addedById?: true
    createdAt?: true
    removedAt?: true
    removedById?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    role?: true
    addedById?: true
    createdAt?: true
    removedAt?: true
    removedById?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    userId?: true
    chatId?: true
    role?: true
    addedById?: true
    createdAt?: true
    removedAt?: true
    removedById?: true
    _all?: true
  }

  export type MemberAggregateArgs = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs = {
    where?: MemberWhereInput
    orderBy?: Enumerable<MemberOrderByWithAggregationInput>
    by: MemberScalarFieldEnum[]
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }


  export type MemberGroupByOutputType = {
    id: number
    userId: number
    chatId: number
    role: Role
    addedById: number
    createdAt: Date
    removedAt: Date | null
    removedById: number | null
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect = {
    id?: boolean
    userId?: boolean
    chatId?: boolean
    role?: boolean
    addedById?: boolean
    createdAt?: boolean
    removedAt?: boolean
    removedById?: boolean
    user?: boolean | UserArgs
    chat?: boolean | ChatArgs
    chatUpdates?: boolean | Member$chatUpdatesArgs
    addedBy?: boolean | UserArgs
    removedBy?: boolean | UserArgs
    _count?: boolean | MemberCountOutputTypeArgs
  }


  export type MemberInclude = {
    user?: boolean | UserArgs
    chat?: boolean | ChatArgs
    chatUpdates?: boolean | Member$chatUpdatesArgs
    addedBy?: boolean | UserArgs
    removedBy?: boolean | UserArgs
    _count?: boolean | MemberCountOutputTypeArgs
  }

  export type MemberGetPayload<S extends boolean | null | undefined | MemberArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Member :
    S extends undefined ? never :
    S extends { include: any } & (MemberArgs | MemberFindManyArgs)
    ? Member  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'chat' ? ChatGetPayload<S['include'][P]> :
        P extends 'chatUpdates' ? Array < ChatUpdateGetPayload<S['include'][P]>>  :
        P extends 'addedBy' ? UserGetPayload<S['include'][P]> :
        P extends 'removedBy' ? UserGetPayload<S['include'][P]> | null :
        P extends '_count' ? MemberCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MemberArgs | MemberFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'chat' ? ChatGetPayload<S['select'][P]> :
        P extends 'chatUpdates' ? Array < ChatUpdateGetPayload<S['select'][P]>>  :
        P extends 'addedBy' ? UserGetPayload<S['select'][P]> :
        P extends 'removedBy' ? UserGetPayload<S['select'][P]> | null :
        P extends '_count' ? MemberCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Member ? Member[P] : never
  } 
      : Member


  type MemberCountArgs = 
    Omit<MemberFindManyArgs, 'select' | 'include'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MemberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MemberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Member'> extends True ? Prisma__MemberClient<MemberGetPayload<T>> : Prisma__MemberClient<MemberGetPayload<T> | null, null>

    /**
     * Find one Member that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MemberFindUniqueOrThrowArgs>
    ): Prisma__MemberClient<MemberGetPayload<T>>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MemberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MemberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Member'> extends True ? Prisma__MemberClient<MemberGetPayload<T>> : Prisma__MemberClient<MemberGetPayload<T> | null, null>

    /**
     * Find the first Member that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MemberFindFirstOrThrowArgs>
    ): Prisma__MemberClient<MemberGetPayload<T>>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MemberFindManyArgs>(
      args?: SelectSubset<T, MemberFindManyArgs>
    ): Prisma.PrismaPromise<Array<MemberGetPayload<T>>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
    **/
    create<T extends MemberCreateArgs>(
      args: SelectSubset<T, MemberCreateArgs>
    ): Prisma__MemberClient<MemberGetPayload<T>>

    /**
     * Create many Members.
     *     @param {MemberCreateManyArgs} args - Arguments to create many Members.
     *     @example
     *     // Create many Members
     *     const member = await prisma.member.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MemberCreateManyArgs>(
      args?: SelectSubset<T, MemberCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
    **/
    delete<T extends MemberDeleteArgs>(
      args: SelectSubset<T, MemberDeleteArgs>
    ): Prisma__MemberClient<MemberGetPayload<T>>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MemberUpdateArgs>(
      args: SelectSubset<T, MemberUpdateArgs>
    ): Prisma__MemberClient<MemberGetPayload<T>>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MemberDeleteManyArgs>(
      args?: SelectSubset<T, MemberDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MemberUpdateManyArgs>(
      args: SelectSubset<T, MemberUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
    **/
    upsert<T extends MemberUpsertArgs>(
      args: SelectSubset<T, MemberUpsertArgs>
    ): Prisma__MemberClient<MemberGetPayload<T>>

    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MemberClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    chat<T extends ChatArgs= {}>(args?: Subset<T, ChatArgs>): Prisma__ChatClient<ChatGetPayload<T> | Null>;

    chatUpdates<T extends Member$chatUpdatesArgs= {}>(args?: Subset<T, Member$chatUpdatesArgs>): Prisma.PrismaPromise<Array<ChatUpdateGetPayload<T>>| Null>;

    addedBy<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    removedBy<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Member base type for findUnique actions
   */
  export type MemberFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUnique
   */
  export interface MemberFindUniqueArgs extends MemberFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member base type for findFirst actions
   */
  export type MemberFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: Enumerable<MemberScalarFieldEnum>
  }

  /**
   * Member findFirst
   */
  export interface MemberFindFirstArgs extends MemberFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * Member findMany
   */
  export type MemberFindManyArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * Member create
   */
  export type MemberCreateArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }


  /**
   * Member createMany
   */
  export type MemberCreateManyArgs = {
    /**
     * The data used to create many Members.
     */
    data: Enumerable<MemberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Member update
   */
  export type MemberUpdateArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
  }


  /**
   * Member upsert
   */
  export type MemberUpsertArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }


  /**
   * Member delete
   */
  export type MemberDeleteArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }


  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
  }


  /**
   * Member.chatUpdates
   */
  export type Member$chatUpdatesArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    where?: ChatUpdateWhereInput
    orderBy?: Enumerable<ChatUpdateOrderByWithRelationInput>
    cursor?: ChatUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChatUpdateScalarFieldEnum>
  }


  /**
   * Member without action
   */
  export type MemberArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
  }



  /**
   * Model Chat
   */


  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type ChatSumAggregateOutputType = {
    id: number | null
    createdById: number | null
  }

  export type ChatMinAggregateOutputType = {
    id: number | null
    type: ChatType | null
    name: string | null
    description: string | null
    createdById: number | null
    updatedAt: Date | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: number | null
    type: ChatType | null
    name: string | null
    description: string | null
    createdById: number | null
    updatedAt: Date | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    type: number
    name: number
    description: number
    createdById: number
    updatedAt: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type ChatAvgAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type ChatSumAggregateInputType = {
    id?: true
    createdById?: true
  }

  export type ChatMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
    deletedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
    deletedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    description?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: Enumerable<ChatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs = {
    where?: ChatWhereInput
    orderBy?: Enumerable<ChatOrderByWithAggregationInput>
    by: ChatScalarFieldEnum[]
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _avg?: ChatAvgAggregateInputType
    _sum?: ChatSumAggregateInputType
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }


  export type ChatGroupByOutputType = {
    id: number
    type: ChatType
    name: string | null
    description: string | null
    createdById: number
    updatedAt: Date
    createdAt: Date
    deletedAt: Date | null
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect = {
    id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserArgs
    members?: boolean | Chat$membersArgs
    event?: boolean | Chat$eventArgs
    alerts?: boolean | Chat$alertsArgs
    _count?: boolean | ChatCountOutputTypeArgs
  }


  export type ChatInclude = {
    createdBy?: boolean | UserArgs
    members?: boolean | Chat$membersArgs
    event?: boolean | Chat$eventArgs
    alerts?: boolean | Chat$alertsArgs
    _count?: boolean | ChatCountOutputTypeArgs
  }

  export type ChatGetPayload<S extends boolean | null | undefined | ChatArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Chat :
    S extends undefined ? never :
    S extends { include: any } & (ChatArgs | ChatFindManyArgs)
    ? Chat  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'createdBy' ? UserGetPayload<S['include'][P]> :
        P extends 'members' ? Array < MemberGetPayload<S['include'][P]>>  :
        P extends 'event' ? Array < EventGetPayload<S['include'][P]>>  :
        P extends 'alerts' ? Array < AlertGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChatCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChatArgs | ChatFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'createdBy' ? UserGetPayload<S['select'][P]> :
        P extends 'members' ? Array < MemberGetPayload<S['select'][P]>>  :
        P extends 'event' ? Array < EventGetPayload<S['select'][P]>>  :
        P extends 'alerts' ? Array < AlertGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChatCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Chat ? Chat[P] : never
  } 
      : Chat


  type ChatCountArgs = 
    Omit<ChatFindManyArgs, 'select' | 'include'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Chat'> extends True ? Prisma__ChatClient<ChatGetPayload<T>> : Prisma__ChatClient<ChatGetPayload<T> | null, null>

    /**
     * Find one Chat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChatFindUniqueOrThrowArgs>
    ): Prisma__ChatClient<ChatGetPayload<T>>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Chat'> extends True ? Prisma__ChatClient<ChatGetPayload<T>> : Prisma__ChatClient<ChatGetPayload<T> | null, null>

    /**
     * Find the first Chat that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChatFindFirstOrThrowArgs>
    ): Prisma__ChatClient<ChatGetPayload<T>>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChatFindManyArgs>(
      args?: SelectSubset<T, ChatFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChatGetPayload<T>>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
    **/
    create<T extends ChatCreateArgs>(
      args: SelectSubset<T, ChatCreateArgs>
    ): Prisma__ChatClient<ChatGetPayload<T>>

    /**
     * Create many Chats.
     *     @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     *     @example
     *     // Create many Chats
     *     const chat = await prisma.chat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatCreateManyArgs>(
      args?: SelectSubset<T, ChatCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
    **/
    delete<T extends ChatDeleteArgs>(
      args: SelectSubset<T, ChatDeleteArgs>
    ): Prisma__ChatClient<ChatGetPayload<T>>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatUpdateArgs>(
      args: SelectSubset<T, ChatUpdateArgs>
    ): Prisma__ChatClient<ChatGetPayload<T>>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatDeleteManyArgs>(
      args?: SelectSubset<T, ChatDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatUpdateManyArgs>(
      args: SelectSubset<T, ChatUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
    **/
    upsert<T extends ChatUpsertArgs>(
      args: SelectSubset<T, ChatUpsertArgs>
    ): Prisma__ChatClient<ChatGetPayload<T>>

    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    createdBy<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    members<T extends Chat$membersArgs= {}>(args?: Subset<T, Chat$membersArgs>): Prisma.PrismaPromise<Array<MemberGetPayload<T>>| Null>;

    event<T extends Chat$eventArgs= {}>(args?: Subset<T, Chat$eventArgs>): Prisma.PrismaPromise<Array<EventGetPayload<T>>| Null>;

    alerts<T extends Chat$alertsArgs= {}>(args?: Subset<T, Chat$alertsArgs>): Prisma.PrismaPromise<Array<AlertGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Chat base type for findUnique actions
   */
  export type ChatFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUnique
   */
  export interface ChatFindUniqueArgs extends ChatFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }


  /**
   * Chat base type for findFirst actions
   */
  export type ChatFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: Enumerable<ChatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: Enumerable<ChatScalarFieldEnum>
  }

  /**
   * Chat findFirst
   */
  export interface ChatFindFirstArgs extends ChatFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: Enumerable<ChatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: Enumerable<ChatScalarFieldEnum>
  }


  /**
   * Chat findMany
   */
  export type ChatFindManyArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: Enumerable<ChatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: Enumerable<ChatScalarFieldEnum>
  }


  /**
   * Chat create
   */
  export type ChatCreateArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }


  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs = {
    /**
     * The data used to create many Chats.
     */
    data: Enumerable<ChatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Chat update
   */
  export type ChatUpdateArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }


  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }


  /**
   * Chat upsert
   */
  export type ChatUpsertArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }


  /**
   * Chat delete
   */
  export type ChatDeleteArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }


  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }


  /**
   * Chat.members
   */
  export type Chat$membersArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    where?: MemberWhereInput
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * Chat.event
   */
  export type Chat$eventArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Chat.alerts
   */
  export type Chat$alertsArgs = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AlertInclude | null
    where?: AlertWhereInput
    orderBy?: Enumerable<AlertOrderByWithRelationInput>
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AlertScalarFieldEnum>
  }


  /**
   * Chat without action
   */
  export type ChatArgs = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatInclude | null
  }



  /**
   * Model Event
   */


  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
    chatId: number | null
    createdById: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
    chatId: number | null
    createdById: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    type: EventType | null
    chatId: number | null
    createdById: number | null
    updatedAt: Date | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    type: EventType | null
    chatId: number | null
    createdById: number | null
    updatedAt: Date | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    type: number
    chatId: number
    createdById: number
    updatedAt: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    chatId?: true
    createdById?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    chatId?: true
    createdById?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    type?: true
    chatId?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
    deletedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    type?: true
    chatId?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
    deletedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    type?: true
    chatId?: true
    createdById?: true
    updatedAt?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EventAggregateArgs = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs = {
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByWithAggregationInput>
    by: EventScalarFieldEnum[]
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }


  export type EventGroupByOutputType = {
    id: number
    type: EventType
    chatId: number
    createdById: number
    updatedAt: Date
    createdAt: Date
    deletedAt: Date | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect = {
    id?: boolean
    type?: boolean
    chatId?: boolean
    createdById?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    chat?: boolean | ChatArgs
    createdBy?: boolean | UserArgs
    message?: boolean | MessageArgs
    chatUpdate?: boolean | ChatUpdateArgs
  }


  export type EventInclude = {
    chat?: boolean | ChatArgs
    createdBy?: boolean | UserArgs
    message?: boolean | MessageArgs
    chatUpdate?: boolean | ChatUpdateArgs
  }

  export type EventGetPayload<S extends boolean | null | undefined | EventArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Event :
    S extends undefined ? never :
    S extends { include: any } & (EventArgs | EventFindManyArgs)
    ? Event  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'chat' ? ChatGetPayload<S['include'][P]> :
        P extends 'createdBy' ? UserGetPayload<S['include'][P]> :
        P extends 'message' ? MessageGetPayload<S['include'][P]> | null :
        P extends 'chatUpdate' ? ChatUpdateGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (EventArgs | EventFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'chat' ? ChatGetPayload<S['select'][P]> :
        P extends 'createdBy' ? UserGetPayload<S['select'][P]> :
        P extends 'message' ? MessageGetPayload<S['select'][P]> | null :
        P extends 'chatUpdate' ? ChatUpdateGetPayload<S['select'][P]> | null :  P extends keyof Event ? Event[P] : never
  } 
      : Event


  type EventCountArgs = 
    Omit<EventFindManyArgs, 'select' | 'include'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Event'> extends True ? Prisma__EventClient<EventGetPayload<T>> : Prisma__EventClient<EventGetPayload<T> | null, null>

    /**
     * Find one Event that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EventFindUniqueOrThrowArgs>
    ): Prisma__EventClient<EventGetPayload<T>>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Event'> extends True ? Prisma__EventClient<EventGetPayload<T>> : Prisma__EventClient<EventGetPayload<T> | null, null>

    /**
     * Find the first Event that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EventFindFirstOrThrowArgs>
    ): Prisma__EventClient<EventGetPayload<T>>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs>
    ): Prisma.PrismaPromise<Array<EventGetPayload<T>>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs>
    ): Prisma__EventClient<EventGetPayload<T>>

    /**
     * Create many Events.
     *     @param {EventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs>
    ): Prisma__EventClient<EventGetPayload<T>>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs>
    ): Prisma__EventClient<EventGetPayload<T>>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs>
    ): Prisma__EventClient<EventGetPayload<T>>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chat<T extends ChatArgs= {}>(args?: Subset<T, ChatArgs>): Prisma__ChatClient<ChatGetPayload<T> | Null>;

    createdBy<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    message<T extends MessageArgs= {}>(args?: Subset<T, MessageArgs>): Prisma__MessageClient<MessageGetPayload<T> | Null>;

    chatUpdate<T extends ChatUpdateArgs= {}>(args?: Subset<T, ChatUpdateArgs>): Prisma__ChatUpdateClient<ChatUpdateGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Event base type for findUnique actions
   */
  export type EventFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUnique
   */
  export interface EventFindUniqueArgs extends EventFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event base type for findFirst actions
   */
  export type EventFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: Enumerable<EventScalarFieldEnum>
  }

  /**
   * Event findFirst
   */
  export interface EventFindFirstArgs extends EventFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event findMany
   */
  export type EventFindManyArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event create
   */
  export type EventCreateArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }


  /**
   * Event createMany
   */
  export type EventCreateManyArgs = {
    /**
     * The data used to create many Events.
     */
    data: Enumerable<EventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Event update
   */
  export type EventUpdateArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }


  /**
   * Event upsert
   */
  export type EventUpsertArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }


  /**
   * Event delete
   */
  export type EventDeleteArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }


  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }


  /**
   * Event without action
   */
  export type EventArgs = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EventInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    eventId: number | null
  }

  export type MessageSumAggregateOutputType = {
    eventId: number | null
  }

  export type MessageMinAggregateOutputType = {
    eventId: number | null
    content: string | null
  }

  export type MessageMaxAggregateOutputType = {
    eventId: number | null
    content: string | null
  }

  export type MessageCountAggregateOutputType = {
    eventId: number
    content: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    eventId?: true
  }

  export type MessageSumAggregateInputType = {
    eventId?: true
  }

  export type MessageMinAggregateInputType = {
    eventId?: true
    content?: true
  }

  export type MessageMaxAggregateInputType = {
    eventId?: true
    content?: true
  }

  export type MessageCountAggregateInputType = {
    eventId?: true
    content?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: MessageScalarFieldEnum[]
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    eventId: number
    content: string
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    eventId?: boolean
    content?: boolean
    event?: boolean | EventArgs
    likedBy?: boolean | Message$likedByArgs
    _count?: boolean | MessageCountOutputTypeArgs
  }


  export type MessageInclude = {
    event?: boolean | EventArgs
    likedBy?: boolean | Message$likedByArgs
    _count?: boolean | MessageCountOutputTypeArgs
  }

  export type MessageGetPayload<S extends boolean | null | undefined | MessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Message :
    S extends undefined ? never :
    S extends { include: any } & (MessageArgs | MessageFindManyArgs)
    ? Message  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'event' ? EventGetPayload<S['include'][P]> :
        P extends 'likedBy' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? MessageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MessageArgs | MessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'event' ? EventGetPayload<S['select'][P]> :
        P extends 'likedBy' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? MessageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Message ? Message[P] : never
  } 
      : Message


  type MessageCountArgs = 
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find the first Message that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `eventId`
     * const messageWithEventIdOnly = await prisma.message.findMany({ select: { eventId: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<MessageGetPayload<T>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event<T extends EventArgs= {}>(args?: Subset<T, EventArgs>): Prisma__EventClient<EventGetPayload<T> | Null>;

    likedBy<T extends Message$likedByArgs= {}>(args?: Subset<T, Message$likedByArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Message base type for findUnique actions
   */
  export type MessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUnique
   */
  export interface MessageFindUniqueArgs extends MessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message base type for findFirst actions
   */
  export type MessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }

  /**
   * Message findFirst
   */
  export interface MessageFindFirstArgs extends MessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    /**
     * The data used to create many Messages.
     */
    data: Enumerable<MessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message.likedBy
   */
  export type Message$likedByArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
  }



  /**
   * Model ChatUpdate
   */


  export type AggregateChatUpdate = {
    _count: ChatUpdateCountAggregateOutputType | null
    _avg: ChatUpdateAvgAggregateOutputType | null
    _sum: ChatUpdateSumAggregateOutputType | null
    _min: ChatUpdateMinAggregateOutputType | null
    _max: ChatUpdateMaxAggregateOutputType | null
  }

  export type ChatUpdateAvgAggregateOutputType = {
    eventId: number | null
  }

  export type ChatUpdateSumAggregateOutputType = {
    eventId: number | null
  }

  export type ChatUpdateMinAggregateOutputType = {
    eventId: number | null
    type: ChatUpdateType | null
    nameBefore: string | null
    nameAfter: string | null
    descriptionBefore: string | null
    descriptionAfter: string | null
    newRole: Role | null
  }

  export type ChatUpdateMaxAggregateOutputType = {
    eventId: number | null
    type: ChatUpdateType | null
    nameBefore: string | null
    nameAfter: string | null
    descriptionBefore: string | null
    descriptionAfter: string | null
    newRole: Role | null
  }

  export type ChatUpdateCountAggregateOutputType = {
    eventId: number
    type: number
    nameBefore: number
    nameAfter: number
    descriptionBefore: number
    descriptionAfter: number
    newRole: number
    _all: number
  }


  export type ChatUpdateAvgAggregateInputType = {
    eventId?: true
  }

  export type ChatUpdateSumAggregateInputType = {
    eventId?: true
  }

  export type ChatUpdateMinAggregateInputType = {
    eventId?: true
    type?: true
    nameBefore?: true
    nameAfter?: true
    descriptionBefore?: true
    descriptionAfter?: true
    newRole?: true
  }

  export type ChatUpdateMaxAggregateInputType = {
    eventId?: true
    type?: true
    nameBefore?: true
    nameAfter?: true
    descriptionBefore?: true
    descriptionAfter?: true
    newRole?: true
  }

  export type ChatUpdateCountAggregateInputType = {
    eventId?: true
    type?: true
    nameBefore?: true
    nameAfter?: true
    descriptionBefore?: true
    descriptionAfter?: true
    newRole?: true
    _all?: true
  }

  export type ChatUpdateAggregateArgs = {
    /**
     * Filter which ChatUpdate to aggregate.
     */
    where?: ChatUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUpdates to fetch.
     */
    orderBy?: Enumerable<ChatUpdateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatUpdates
    **/
    _count?: true | ChatUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatUpdateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatUpdateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatUpdateMaxAggregateInputType
  }

  export type GetChatUpdateAggregateType<T extends ChatUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateChatUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatUpdate[P]>
      : GetScalarType<T[P], AggregateChatUpdate[P]>
  }




  export type ChatUpdateGroupByArgs = {
    where?: ChatUpdateWhereInput
    orderBy?: Enumerable<ChatUpdateOrderByWithAggregationInput>
    by: ChatUpdateScalarFieldEnum[]
    having?: ChatUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatUpdateCountAggregateInputType | true
    _avg?: ChatUpdateAvgAggregateInputType
    _sum?: ChatUpdateSumAggregateInputType
    _min?: ChatUpdateMinAggregateInputType
    _max?: ChatUpdateMaxAggregateInputType
  }


  export type ChatUpdateGroupByOutputType = {
    eventId: number
    type: ChatUpdateType
    nameBefore: string | null
    nameAfter: string | null
    descriptionBefore: string | null
    descriptionAfter: string | null
    newRole: Role | null
    _count: ChatUpdateCountAggregateOutputType | null
    _avg: ChatUpdateAvgAggregateOutputType | null
    _sum: ChatUpdateSumAggregateOutputType | null
    _min: ChatUpdateMinAggregateOutputType | null
    _max: ChatUpdateMaxAggregateOutputType | null
  }

  type GetChatUpdateGroupByPayload<T extends ChatUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChatUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], ChatUpdateGroupByOutputType[P]>
        }
      >
    >


  export type ChatUpdateSelect = {
    eventId?: boolean
    type?: boolean
    nameBefore?: boolean
    nameAfter?: boolean
    descriptionBefore?: boolean
    descriptionAfter?: boolean
    newRole?: boolean
    event?: boolean | EventArgs
    members?: boolean | ChatUpdate$membersArgs
    _count?: boolean | ChatUpdateCountOutputTypeArgs
  }


  export type ChatUpdateInclude = {
    event?: boolean | EventArgs
    members?: boolean | ChatUpdate$membersArgs
    _count?: boolean | ChatUpdateCountOutputTypeArgs
  }

  export type ChatUpdateGetPayload<S extends boolean | null | undefined | ChatUpdateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ChatUpdate :
    S extends undefined ? never :
    S extends { include: any } & (ChatUpdateArgs | ChatUpdateFindManyArgs)
    ? ChatUpdate  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'event' ? EventGetPayload<S['include'][P]> :
        P extends 'members' ? Array < MemberGetPayload<S['include'][P]>>  :
        P extends '_count' ? ChatUpdateCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ChatUpdateArgs | ChatUpdateFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'event' ? EventGetPayload<S['select'][P]> :
        P extends 'members' ? Array < MemberGetPayload<S['select'][P]>>  :
        P extends '_count' ? ChatUpdateCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ChatUpdate ? ChatUpdate[P] : never
  } 
      : ChatUpdate


  type ChatUpdateCountArgs = 
    Omit<ChatUpdateFindManyArgs, 'select' | 'include'> & {
      select?: ChatUpdateCountAggregateInputType | true
    }

  export interface ChatUpdateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ChatUpdate that matches the filter.
     * @param {ChatUpdateFindUniqueArgs} args - Arguments to find a ChatUpdate
     * @example
     * // Get one ChatUpdate
     * const chatUpdate = await prisma.chatUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatUpdateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatUpdateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChatUpdate'> extends True ? Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>> : Prisma__ChatUpdateClient<ChatUpdateGetPayload<T> | null, null>

    /**
     * Find one ChatUpdate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChatUpdateFindUniqueOrThrowArgs} args - Arguments to find a ChatUpdate
     * @example
     * // Get one ChatUpdate
     * const chatUpdate = await prisma.chatUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatUpdateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ChatUpdateFindUniqueOrThrowArgs>
    ): Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>>

    /**
     * Find the first ChatUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateFindFirstArgs} args - Arguments to find a ChatUpdate
     * @example
     * // Get one ChatUpdate
     * const chatUpdate = await prisma.chatUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatUpdateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatUpdateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChatUpdate'> extends True ? Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>> : Prisma__ChatUpdateClient<ChatUpdateGetPayload<T> | null, null>

    /**
     * Find the first ChatUpdate that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateFindFirstOrThrowArgs} args - Arguments to find a ChatUpdate
     * @example
     * // Get one ChatUpdate
     * const chatUpdate = await prisma.chatUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatUpdateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChatUpdateFindFirstOrThrowArgs>
    ): Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>>

    /**
     * Find zero or more ChatUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatUpdates
     * const chatUpdates = await prisma.chatUpdate.findMany()
     * 
     * // Get first 10 ChatUpdates
     * const chatUpdates = await prisma.chatUpdate.findMany({ take: 10 })
     * 
     * // Only select the `eventId`
     * const chatUpdateWithEventIdOnly = await prisma.chatUpdate.findMany({ select: { eventId: true } })
     * 
    **/
    findMany<T extends ChatUpdateFindManyArgs>(
      args?: SelectSubset<T, ChatUpdateFindManyArgs>
    ): Prisma.PrismaPromise<Array<ChatUpdateGetPayload<T>>>

    /**
     * Create a ChatUpdate.
     * @param {ChatUpdateCreateArgs} args - Arguments to create a ChatUpdate.
     * @example
     * // Create one ChatUpdate
     * const ChatUpdate = await prisma.chatUpdate.create({
     *   data: {
     *     // ... data to create a ChatUpdate
     *   }
     * })
     * 
    **/
    create<T extends ChatUpdateCreateArgs>(
      args: SelectSubset<T, ChatUpdateCreateArgs>
    ): Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>>

    /**
     * Create many ChatUpdates.
     *     @param {ChatUpdateCreateManyArgs} args - Arguments to create many ChatUpdates.
     *     @example
     *     // Create many ChatUpdates
     *     const chatUpdate = await prisma.chatUpdate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatUpdateCreateManyArgs>(
      args?: SelectSubset<T, ChatUpdateCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatUpdate.
     * @param {ChatUpdateDeleteArgs} args - Arguments to delete one ChatUpdate.
     * @example
     * // Delete one ChatUpdate
     * const ChatUpdate = await prisma.chatUpdate.delete({
     *   where: {
     *     // ... filter to delete one ChatUpdate
     *   }
     * })
     * 
    **/
    delete<T extends ChatUpdateDeleteArgs>(
      args: SelectSubset<T, ChatUpdateDeleteArgs>
    ): Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>>

    /**
     * Update one ChatUpdate.
     * @param {ChatUpdateUpdateArgs} args - Arguments to update one ChatUpdate.
     * @example
     * // Update one ChatUpdate
     * const chatUpdate = await prisma.chatUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatUpdateUpdateArgs>(
      args: SelectSubset<T, ChatUpdateUpdateArgs>
    ): Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>>

    /**
     * Delete zero or more ChatUpdates.
     * @param {ChatUpdateDeleteManyArgs} args - Arguments to filter ChatUpdates to delete.
     * @example
     * // Delete a few ChatUpdates
     * const { count } = await prisma.chatUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatUpdateDeleteManyArgs>(
      args?: SelectSubset<T, ChatUpdateDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatUpdates
     * const chatUpdate = await prisma.chatUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatUpdateUpdateManyArgs>(
      args: SelectSubset<T, ChatUpdateUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatUpdate.
     * @param {ChatUpdateUpsertArgs} args - Arguments to update or create a ChatUpdate.
     * @example
     * // Update or create a ChatUpdate
     * const chatUpdate = await prisma.chatUpdate.upsert({
     *   create: {
     *     // ... data to create a ChatUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatUpdate we want to update
     *   }
     * })
    **/
    upsert<T extends ChatUpdateUpsertArgs>(
      args: SelectSubset<T, ChatUpdateUpsertArgs>
    ): Prisma__ChatUpdateClient<ChatUpdateGetPayload<T>>

    /**
     * Count the number of ChatUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateCountArgs} args - Arguments to filter ChatUpdates to count.
     * @example
     * // Count the number of ChatUpdates
     * const count = await prisma.chatUpdate.count({
     *   where: {
     *     // ... the filter for the ChatUpdates we want to count
     *   }
     * })
    **/
    count<T extends ChatUpdateCountArgs>(
      args?: Subset<T, ChatUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatUpdateAggregateArgs>(args: Subset<T, ChatUpdateAggregateArgs>): Prisma.PrismaPromise<GetChatUpdateAggregateType<T>>

    /**
     * Group by ChatUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatUpdateGroupByArgs['orderBy'] }
        : { orderBy?: ChatUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatUpdateClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    event<T extends EventArgs= {}>(args?: Subset<T, EventArgs>): Prisma__EventClient<EventGetPayload<T> | Null>;

    members<T extends ChatUpdate$membersArgs= {}>(args?: Subset<T, ChatUpdate$membersArgs>): Prisma.PrismaPromise<Array<MemberGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChatUpdate base type for findUnique actions
   */
  export type ChatUpdateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * Filter, which ChatUpdate to fetch.
     */
    where: ChatUpdateWhereUniqueInput
  }

  /**
   * ChatUpdate findUnique
   */
  export interface ChatUpdateFindUniqueArgs extends ChatUpdateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatUpdate findUniqueOrThrow
   */
  export type ChatUpdateFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * Filter, which ChatUpdate to fetch.
     */
    where: ChatUpdateWhereUniqueInput
  }


  /**
   * ChatUpdate base type for findFirst actions
   */
  export type ChatUpdateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * Filter, which ChatUpdate to fetch.
     */
    where?: ChatUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUpdates to fetch.
     */
    orderBy?: Enumerable<ChatUpdateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatUpdates.
     */
    cursor?: ChatUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatUpdates.
     */
    distinct?: Enumerable<ChatUpdateScalarFieldEnum>
  }

  /**
   * ChatUpdate findFirst
   */
  export interface ChatUpdateFindFirstArgs extends ChatUpdateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatUpdate findFirstOrThrow
   */
  export type ChatUpdateFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * Filter, which ChatUpdate to fetch.
     */
    where?: ChatUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUpdates to fetch.
     */
    orderBy?: Enumerable<ChatUpdateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatUpdates.
     */
    cursor?: ChatUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatUpdates.
     */
    distinct?: Enumerable<ChatUpdateScalarFieldEnum>
  }


  /**
   * ChatUpdate findMany
   */
  export type ChatUpdateFindManyArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * Filter, which ChatUpdates to fetch.
     */
    where?: ChatUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatUpdates to fetch.
     */
    orderBy?: Enumerable<ChatUpdateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatUpdates.
     */
    cursor?: ChatUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatUpdates.
     */
    skip?: number
    distinct?: Enumerable<ChatUpdateScalarFieldEnum>
  }


  /**
   * ChatUpdate create
   */
  export type ChatUpdateCreateArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * The data needed to create a ChatUpdate.
     */
    data: XOR<ChatUpdateCreateInput, ChatUpdateUncheckedCreateInput>
  }


  /**
   * ChatUpdate createMany
   */
  export type ChatUpdateCreateManyArgs = {
    /**
     * The data used to create many ChatUpdates.
     */
    data: Enumerable<ChatUpdateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChatUpdate update
   */
  export type ChatUpdateUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * The data needed to update a ChatUpdate.
     */
    data: XOR<ChatUpdateUpdateInput, ChatUpdateUncheckedUpdateInput>
    /**
     * Choose, which ChatUpdate to update.
     */
    where: ChatUpdateWhereUniqueInput
  }


  /**
   * ChatUpdate updateMany
   */
  export type ChatUpdateUpdateManyArgs = {
    /**
     * The data used to update ChatUpdates.
     */
    data: XOR<ChatUpdateUpdateManyMutationInput, ChatUpdateUncheckedUpdateManyInput>
    /**
     * Filter which ChatUpdates to update
     */
    where?: ChatUpdateWhereInput
  }


  /**
   * ChatUpdate upsert
   */
  export type ChatUpdateUpsertArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * The filter to search for the ChatUpdate to update in case it exists.
     */
    where: ChatUpdateWhereUniqueInput
    /**
     * In case the ChatUpdate found by the `where` argument doesn't exist, create a new ChatUpdate with this data.
     */
    create: XOR<ChatUpdateCreateInput, ChatUpdateUncheckedCreateInput>
    /**
     * In case the ChatUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateUpdateInput, ChatUpdateUncheckedUpdateInput>
  }


  /**
   * ChatUpdate delete
   */
  export type ChatUpdateDeleteArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
    /**
     * Filter which ChatUpdate to delete.
     */
    where: ChatUpdateWhereUniqueInput
  }


  /**
   * ChatUpdate deleteMany
   */
  export type ChatUpdateDeleteManyArgs = {
    /**
     * Filter which ChatUpdates to delete
     */
    where?: ChatUpdateWhereInput
  }


  /**
   * ChatUpdate.members
   */
  export type ChatUpdate$membersArgs = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MemberInclude | null
    where?: MemberWhereInput
    orderBy?: Enumerable<MemberOrderByWithRelationInput>
    cursor?: MemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * ChatUpdate without action
   */
  export type ChatUpdateArgs = {
    /**
     * Select specific fields to fetch from the ChatUpdate
     */
    select?: ChatUpdateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatUpdateInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdById: 'createdById',
    createdAt: 'createdAt',
    chatId: 'chatId',
    requestId: 'requestId'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    description: 'description',
    createdById: 'createdById',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatUpdateScalarFieldEnum: {
    eventId: 'eventId',
    type: 'type',
    nameBefore: 'nameBefore',
    nameAfter: 'nameAfter',
    descriptionBefore: 'descriptionBefore',
    descriptionAfter: 'descriptionAfter',
    newRole: 'newRole'
  };

  export type ChatUpdateScalarFieldEnum = (typeof ChatUpdateScalarFieldEnum)[keyof typeof ChatUpdateScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    chatId: 'chatId',
    createdById: 'createdById',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    chatId: 'chatId',
    role: 'role',
    addedById: 'addedById',
    createdAt: 'createdAt',
    removedAt: 'removedAt',
    removedById: 'removedById'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    eventId: 'eventId',
    content: 'content'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const RequestScalarFieldEnum: {
    id: 'id',
    type: 'type',
    state: 'state',
    recipientId: 'recipientId',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    username: 'username',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    username?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    friends?: UserListRelationFilter
    friendsOf?: UserListRelationFilter
    likedMessages?: MessageListRelationFilter
    creatorOfChats?: ChatListRelationFilter
    alerts?: AlertListRelationFilter
    alertsSent?: AlertListRelationFilter
    requests?: RequestListRelationFilter
    requestsSent?: RequestListRelationFilter
    eventsCreated?: EventListRelationFilter
    memberOfChats?: MemberListRelationFilter
    membersAddedToChat?: MemberListRelationFilter
    membersRemoved?: MemberListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    friends?: UserOrderByRelationAggregateInput
    friendsOf?: UserOrderByRelationAggregateInput
    likedMessages?: MessageOrderByRelationAggregateInput
    creatorOfChats?: ChatOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    alertsSent?: AlertOrderByRelationAggregateInput
    requests?: RequestOrderByRelationAggregateInput
    requestsSent?: RequestOrderByRelationAggregateInput
    eventsCreated?: EventOrderByRelationAggregateInput
    memberOfChats?: MemberOrderByRelationAggregateInput
    membersAddedToChat?: MemberOrderByRelationAggregateInput
    membersRemoved?: MemberOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
    username?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    username?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RequestWhereInput = {
    AND?: Enumerable<RequestWhereInput>
    OR?: Enumerable<RequestWhereInput>
    NOT?: Enumerable<RequestWhereInput>
    id?: IntFilter | number
    type?: EnumRequestTypeFilter | RequestType
    state?: EnumRequestStateFilter | RequestState
    recipientId?: IntFilter | number
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    recipient?: XOR<UserRelationFilter, UserWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    alert?: XOR<AlertRelationFilter, AlertWhereInput> | null
  }

  export type RequestOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    state?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    alert?: AlertOrderByWithRelationInput
  }

  export type RequestWhereUniqueInput = {
    id?: number
    createdAt?: Date | string
    recipientId_createdById_type?: RequestRecipientIdCreatedByIdTypeCompoundUniqueInput
  }

  export type RequestOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    state?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: RequestCountOrderByAggregateInput
    _avg?: RequestAvgOrderByAggregateInput
    _max?: RequestMaxOrderByAggregateInput
    _min?: RequestMinOrderByAggregateInput
    _sum?: RequestSumOrderByAggregateInput
  }

  export type RequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<RequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumRequestTypeWithAggregatesFilter | RequestType
    state?: EnumRequestStateWithAggregatesFilter | RequestState
    recipientId?: IntWithAggregatesFilter | number
    createdById?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AlertWhereInput = {
    AND?: Enumerable<AlertWhereInput>
    OR?: Enumerable<AlertWhereInput>
    NOT?: Enumerable<AlertWhereInput>
    id?: IntFilter | number
    type?: EnumAlertTypeFilter | AlertType
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    chatId?: IntNullableFilter | number | null
    requestId?: IntNullableFilter | number | null
    recipients?: UserListRelationFilter
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    chat?: XOR<ChatRelationFilter, ChatWhereInput> | null
    request?: XOR<RequestRelationFilter, RequestWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    chatId?: SortOrder
    requestId?: SortOrder
    recipients?: UserOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
    request?: RequestOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = {
    id?: number
    createdAt?: Date | string
    requestId?: number
  }

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    chatId?: SortOrder
    requestId?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _avg?: AlertAvgOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
    _sum?: AlertSumOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlertScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlertScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlertScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumAlertTypeWithAggregatesFilter | AlertType
    createdById?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    chatId?: IntNullableWithAggregatesFilter | number | null
    requestId?: IntNullableWithAggregatesFilter | number | null
  }

  export type MemberWhereInput = {
    AND?: Enumerable<MemberWhereInput>
    OR?: Enumerable<MemberWhereInput>
    NOT?: Enumerable<MemberWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    chatId?: IntFilter | number
    role?: EnumRoleFilter | Role
    addedById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    removedAt?: DateTimeNullableFilter | Date | string | null
    removedById?: IntNullableFilter | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    chatUpdates?: ChatUpdateListRelationFilter
    addedBy?: XOR<UserRelationFilter, UserWhereInput>
    removedBy?: XOR<UserRelationFilter, UserWhereInput> | null
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    removedById?: SortOrder
    user?: UserOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
    chatUpdates?: ChatUpdateOrderByRelationAggregateInput
    addedBy?: UserOrderByWithRelationInput
    removedBy?: UserOrderByWithRelationInput
  }

  export type MemberWhereUniqueInput = {
    id?: number
    userId_chatId?: MemberUserIdChatIdCompoundUniqueInput
  }

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    removedById?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MemberScalarWhereWithAggregatesInput>
    OR?: Enumerable<MemberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MemberScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    chatId?: IntWithAggregatesFilter | number
    role?: EnumRoleWithAggregatesFilter | Role
    addedById?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    removedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    removedById?: IntNullableWithAggregatesFilter | number | null
  }

  export type ChatWhereInput = {
    AND?: Enumerable<ChatWhereInput>
    OR?: Enumerable<ChatWhereInput>
    NOT?: Enumerable<ChatWhereInput>
    id?: IntFilter | number
    type?: EnumChatTypeFilter | ChatType
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    createdById?: IntFilter | number
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    members?: MemberListRelationFilter
    event?: EventListRelationFilter
    alerts?: AlertListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    members?: MemberOrderByRelationAggregateInput
    event?: EventOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = {
    id?: number
  }

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _avg?: ChatAvgOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
    _sum?: ChatSumOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumChatTypeWithAggregatesFilter | ChatType
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    createdById?: IntWithAggregatesFilter | number
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type EventWhereInput = {
    AND?: Enumerable<EventWhereInput>
    OR?: Enumerable<EventWhereInput>
    NOT?: Enumerable<EventWhereInput>
    id?: IntFilter | number
    type?: EnumEventTypeFilter | EventType
    chatId?: IntFilter | number
    createdById?: IntFilter | number
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    message?: XOR<MessageRelationFilter, MessageWhereInput> | null
    chatUpdate?: XOR<ChatUpdateRelationFilter, ChatUpdateWhereInput> | null
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    message?: MessageOrderByWithRelationInput
    chatUpdate?: ChatUpdateOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = {
    id?: number
  }

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumEventTypeWithAggregatesFilter | EventType
    chatId?: IntWithAggregatesFilter | number
    createdById?: IntWithAggregatesFilter | number
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    eventId?: IntFilter | number
    content?: StringFilter | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    likedBy?: UserListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    eventId?: SortOrder
    content?: SortOrder
    event?: EventOrderByWithRelationInput
    likedBy?: UserOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = {
    eventId?: number
  }

  export type MessageOrderByWithAggregationInput = {
    eventId?: SortOrder
    content?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    eventId?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
  }

  export type ChatUpdateWhereInput = {
    AND?: Enumerable<ChatUpdateWhereInput>
    OR?: Enumerable<ChatUpdateWhereInput>
    NOT?: Enumerable<ChatUpdateWhereInput>
    eventId?: IntFilter | number
    type?: EnumChatUpdateTypeFilter | ChatUpdateType
    nameBefore?: StringNullableFilter | string | null
    nameAfter?: StringNullableFilter | string | null
    descriptionBefore?: StringNullableFilter | string | null
    descriptionAfter?: StringNullableFilter | string | null
    newRole?: EnumRoleNullableFilter | Role | null
    event?: XOR<EventRelationFilter, EventWhereInput>
    members?: MemberListRelationFilter
  }

  export type ChatUpdateOrderByWithRelationInput = {
    eventId?: SortOrder
    type?: SortOrder
    nameBefore?: SortOrder
    nameAfter?: SortOrder
    descriptionBefore?: SortOrder
    descriptionAfter?: SortOrder
    newRole?: SortOrder
    event?: EventOrderByWithRelationInput
    members?: MemberOrderByRelationAggregateInput
  }

  export type ChatUpdateWhereUniqueInput = {
    eventId?: number
  }

  export type ChatUpdateOrderByWithAggregationInput = {
    eventId?: SortOrder
    type?: SortOrder
    nameBefore?: SortOrder
    nameAfter?: SortOrder
    descriptionBefore?: SortOrder
    descriptionAfter?: SortOrder
    newRole?: SortOrder
    _count?: ChatUpdateCountOrderByAggregateInput
    _avg?: ChatUpdateAvgOrderByAggregateInput
    _max?: ChatUpdateMaxOrderByAggregateInput
    _min?: ChatUpdateMinOrderByAggregateInput
    _sum?: ChatUpdateSumOrderByAggregateInput
  }

  export type ChatUpdateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatUpdateScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatUpdateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatUpdateScalarWhereWithAggregatesInput>
    eventId?: IntWithAggregatesFilter | number
    type?: EnumChatUpdateTypeWithAggregatesFilter | ChatUpdateType
    nameBefore?: StringNullableWithAggregatesFilter | string | null
    nameAfter?: StringNullableWithAggregatesFilter | string | null
    descriptionBefore?: StringNullableWithAggregatesFilter | string | null
    descriptionAfter?: StringNullableWithAggregatesFilter | string | null
    newRole?: EnumRoleNullableWithAggregatesFilter | Role | null
  }

  export type UserCreateInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateInput = {
    type: RequestType
    state?: RequestState
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutRequestsInput
    createdBy: UserCreateNestedOneWithoutRequestsSentInput
    alert?: AlertCreateNestedOneWithoutRequestInput
  }

  export type RequestUncheckedCreateInput = {
    id?: number
    type: RequestType
    state?: RequestState
    recipientId: number
    createdById: number
    createdAt?: Date | string
    alert?: AlertUncheckedCreateNestedOneWithoutRequestInput
  }

  export type RequestUpdateInput = {
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutRequestsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRequestsSentNestedInput
    alert?: AlertUpdateOneWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    recipientId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUncheckedUpdateOneWithoutRequestNestedInput
  }

  export type RequestCreateManyInput = {
    id?: number
    type: RequestType
    state?: RequestState
    recipientId: number
    createdById: number
    createdAt?: Date | string
  }

  export type RequestUpdateManyMutationInput = {
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    recipientId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    type: AlertType
    createdAt?: Date | string
    recipients?: UserCreateNestedManyWithoutAlertsInput
    createdBy: UserCreateNestedOneWithoutAlertsSentInput
    chat?: ChatCreateNestedOneWithoutAlertsInput
    request?: RequestCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateInput = {
    id?: number
    type: AlertType
    createdById: number
    createdAt?: Date | string
    chatId?: number | null
    requestId?: number | null
    recipients?: UserUncheckedCreateNestedManyWithoutAlertsInput
  }

  export type AlertUpdateInput = {
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUpdateManyWithoutAlertsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAlertsSentNestedInput
    chat?: ChatUpdateOneWithoutAlertsNestedInput
    request?: RequestUpdateOneWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: NullableIntFieldUpdateOperationsInput | number | null
    requestId?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: UserUncheckedUpdateManyWithoutAlertsNestedInput
  }

  export type AlertCreateManyInput = {
    id?: number
    type: AlertType
    createdById: number
    createdAt?: Date | string
    chatId?: number | null
    requestId?: number | null
  }

  export type AlertUpdateManyMutationInput = {
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: NullableIntFieldUpdateOperationsInput | number | null
    requestId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MemberCreateInput = {
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMemberOfChatsInput
    chat: ChatCreateNestedOneWithoutMembersInput
    chatUpdates?: ChatUpdateCreateNestedManyWithoutMembersInput
    addedBy: UserCreateNestedOneWithoutMembersAddedToChatInput
    removedBy?: UserCreateNestedOneWithoutMembersRemovedInput
  }

  export type MemberUncheckedCreateInput = {
    id?: number
    userId: number
    chatId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
    chatUpdates?: ChatUpdateUncheckedCreateNestedManyWithoutMembersInput
  }

  export type MemberUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMemberOfChatsNestedInput
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    chatUpdates?: ChatUpdateUpdateManyWithoutMembersNestedInput
    addedBy?: UserUpdateOneRequiredWithoutMembersAddedToChatNestedInput
    removedBy?: UserUpdateOneWithoutMembersRemovedNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
    chatUpdates?: ChatUpdateUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type MemberCreateManyInput = {
    id?: number
    userId: number
    chatId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
  }

  export type MemberUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChatCreateInput = {
    type: ChatType
    name?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatorOfChatsInput
    members?: MemberCreateNestedManyWithoutChatInput
    event?: EventCreateNestedManyWithoutChatInput
    alerts?: AlertCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: number
    type: ChatType
    name?: string | null
    description?: string | null
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutChatInput
    event?: EventUncheckedCreateNestedManyWithoutChatInput
    alerts?: AlertUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatorOfChatsNestedInput
    members?: MemberUpdateManyWithoutChatNestedInput
    event?: EventUpdateManyWithoutChatNestedInput
    alerts?: AlertUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutChatNestedInput
    event?: EventUncheckedUpdateManyWithoutChatNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: number
    type: ChatType
    name?: string | null
    description?: string | null
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChatUpdateManyMutationInput = {
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCreateInput = {
    type: EventType
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    chat: ChatCreateNestedOneWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    message?: MessageCreateNestedOneWithoutEventInput
    chatUpdate?: ChatUpdateCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    type: EventType
    chatId: number
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    message?: MessageUncheckedCreateNestedOneWithoutEventInput
    chatUpdate?: ChatUpdateUncheckedCreateNestedOneWithoutEventInput
  }

  export type EventUpdateInput = {
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chat?: ChatUpdateOneRequiredWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    message?: MessageUpdateOneWithoutEventNestedInput
    chatUpdate?: ChatUpdateUpdateOneWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    chatId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUncheckedUpdateOneWithoutEventNestedInput
    chatUpdate?: ChatUpdateUncheckedUpdateOneWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: number
    type: EventType
    chatId: number
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EventUpdateManyMutationInput = {
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    chatId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    content: string
    event: EventCreateNestedOneWithoutMessageInput
    likedBy?: UserCreateNestedManyWithoutLikedMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    eventId: number
    content: string
    likedBy?: UserUncheckedCreateNestedManyWithoutLikedMessagesInput
  }

  export type MessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutMessageNestedInput
    likedBy?: UserUpdateManyWithoutLikedMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likedBy?: UserUncheckedUpdateManyWithoutLikedMessagesNestedInput
  }

  export type MessageCreateManyInput = {
    eventId: number
    content: string
  }

  export type MessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUpdateCreateInput = {
    type: ChatUpdateType
    nameBefore?: string | null
    nameAfter?: string | null
    descriptionBefore?: string | null
    descriptionAfter?: string | null
    newRole?: Role | null
    event: EventCreateNestedOneWithoutChatUpdateInput
    members?: MemberCreateNestedManyWithoutChatUpdatesInput
  }

  export type ChatUpdateUncheckedCreateInput = {
    eventId: number
    type: ChatUpdateType
    nameBefore?: string | null
    nameAfter?: string | null
    descriptionBefore?: string | null
    descriptionAfter?: string | null
    newRole?: Role | null
    members?: MemberUncheckedCreateNestedManyWithoutChatUpdatesInput
  }

  export type ChatUpdateUpdateInput = {
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
    event?: EventUpdateOneRequiredWithoutChatUpdateNestedInput
    members?: MemberUpdateManyWithoutChatUpdatesNestedInput
  }

  export type ChatUpdateUncheckedUpdateInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
    members?: MemberUncheckedUpdateManyWithoutChatUpdatesNestedInput
  }

  export type ChatUpdateCreateManyInput = {
    eventId: number
    type: ChatUpdateType
    nameBefore?: string | null
    nameAfter?: string | null
    descriptionBefore?: string | null
    descriptionAfter?: string | null
    newRole?: Role | null
  }

  export type ChatUpdateUpdateManyMutationInput = {
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
  }

  export type ChatUpdateUncheckedUpdateManyInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type RequestListRelationFilter = {
    every?: RequestWhereInput
    some?: RequestWhereInput
    none?: RequestWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type MemberListRelationFilter = {
    every?: MemberWhereInput
    some?: MemberWhereInput
    none?: MemberWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    username?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumRequestTypeFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeFilter | RequestType
  }

  export type EnumRequestStateFilter = {
    equals?: RequestState
    in?: Enumerable<RequestState>
    notIn?: Enumerable<RequestState>
    not?: NestedEnumRequestStateFilter | RequestState
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AlertRelationFilter = {
    is?: AlertWhereInput | null
    isNot?: AlertWhereInput | null
  }

  export type RequestRecipientIdCreatedByIdTypeCompoundUniqueInput = {
    recipientId: number
    createdById: number
    type: RequestType
  }

  export type RequestCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    state?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestAvgOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
  }

  export type RequestMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    state?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    state?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type RequestSumOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumRequestTypeWithAggregatesFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeWithAggregatesFilter | RequestType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestTypeFilter
    _max?: NestedEnumRequestTypeFilter
  }

  export type EnumRequestStateWithAggregatesFilter = {
    equals?: RequestState
    in?: Enumerable<RequestState>
    notIn?: Enumerable<RequestState>
    not?: NestedEnumRequestStateWithAggregatesFilter | RequestState
    _count?: NestedIntFilter
    _min?: NestedEnumRequestStateFilter
    _max?: NestedEnumRequestStateFilter
  }

  export type EnumAlertTypeFilter = {
    equals?: AlertType
    in?: Enumerable<AlertType>
    notIn?: Enumerable<AlertType>
    not?: NestedEnumAlertTypeFilter | AlertType
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type RequestRelationFilter = {
    is?: RequestWhereInput | null
    isNot?: RequestWhereInput | null
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    chatId?: SortOrder
    requestId?: SortOrder
  }

  export type AlertAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    chatId?: SortOrder
    requestId?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    chatId?: SortOrder
    requestId?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    chatId?: SortOrder
    requestId?: SortOrder
  }

  export type AlertSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    chatId?: SortOrder
    requestId?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter = {
    equals?: AlertType
    in?: Enumerable<AlertType>
    notIn?: Enumerable<AlertType>
    not?: NestedEnumAlertTypeWithAggregatesFilter | AlertType
    _count?: NestedIntFilter
    _min?: NestedEnumAlertTypeFilter
    _max?: NestedEnumAlertTypeFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ChatUpdateListRelationFilter = {
    every?: ChatUpdateWhereInput
    some?: ChatUpdateWhereInput
    none?: ChatUpdateWhereInput
  }

  export type ChatUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberUserIdChatIdCompoundUniqueInput = {
    userId: number
    chatId: number
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    removedById?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    addedById?: SortOrder
    removedById?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    removedById?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    role?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    removedAt?: SortOrder
    removedById?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    chatId?: SortOrder
    addedById?: SortOrder
    removedById?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EnumChatTypeFilter = {
    equals?: ChatType
    in?: Enumerable<ChatType>
    notIn?: Enumerable<ChatType>
    not?: NestedEnumChatTypeFilter | ChatType
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChatAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChatSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
  }

  export type EnumChatTypeWithAggregatesFilter = {
    equals?: ChatType
    in?: Enumerable<ChatType>
    notIn?: Enumerable<ChatType>
    not?: NestedEnumChatTypeWithAggregatesFilter | ChatType
    _count?: NestedIntFilter
    _min?: NestedEnumChatTypeFilter
    _max?: NestedEnumChatTypeFilter
  }

  export type EnumEventTypeFilter = {
    equals?: EventType
    in?: Enumerable<EventType>
    notIn?: Enumerable<EventType>
    not?: NestedEnumEventTypeFilter | EventType
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type ChatUpdateRelationFilter = {
    is?: ChatUpdateWhereInput | null
    isNot?: ChatUpdateWhereInput | null
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    createdById?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    createdById?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    createdById?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter = {
    equals?: EventType
    in?: Enumerable<EventType>
    notIn?: Enumerable<EventType>
    not?: NestedEnumEventTypeWithAggregatesFilter | EventType
    _count?: NestedIntFilter
    _min?: NestedEnumEventTypeFilter
    _max?: NestedEnumEventTypeFilter
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    eventId?: SortOrder
    content?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    eventId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    eventId?: SortOrder
    content?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    eventId?: SortOrder
    content?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    eventId?: SortOrder
  }

  export type EnumChatUpdateTypeFilter = {
    equals?: ChatUpdateType
    in?: Enumerable<ChatUpdateType>
    notIn?: Enumerable<ChatUpdateType>
    not?: NestedEnumChatUpdateTypeFilter | ChatUpdateType
  }

  export type EnumRoleNullableFilter = {
    equals?: Role | null
    in?: Enumerable<Role> | null
    notIn?: Enumerable<Role> | null
    not?: NestedEnumRoleNullableFilter | Role | null
  }

  export type ChatUpdateCountOrderByAggregateInput = {
    eventId?: SortOrder
    type?: SortOrder
    nameBefore?: SortOrder
    nameAfter?: SortOrder
    descriptionBefore?: SortOrder
    descriptionAfter?: SortOrder
    newRole?: SortOrder
  }

  export type ChatUpdateAvgOrderByAggregateInput = {
    eventId?: SortOrder
  }

  export type ChatUpdateMaxOrderByAggregateInput = {
    eventId?: SortOrder
    type?: SortOrder
    nameBefore?: SortOrder
    nameAfter?: SortOrder
    descriptionBefore?: SortOrder
    descriptionAfter?: SortOrder
    newRole?: SortOrder
  }

  export type ChatUpdateMinOrderByAggregateInput = {
    eventId?: SortOrder
    type?: SortOrder
    nameBefore?: SortOrder
    nameAfter?: SortOrder
    descriptionBefore?: SortOrder
    descriptionAfter?: SortOrder
    newRole?: SortOrder
  }

  export type ChatUpdateSumOrderByAggregateInput = {
    eventId?: SortOrder
  }

  export type EnumChatUpdateTypeWithAggregatesFilter = {
    equals?: ChatUpdateType
    in?: Enumerable<ChatUpdateType>
    notIn?: Enumerable<ChatUpdateType>
    not?: NestedEnumChatUpdateTypeWithAggregatesFilter | ChatUpdateType
    _count?: NestedIntFilter
    _min?: NestedEnumChatUpdateTypeFilter
    _max?: NestedEnumChatUpdateTypeFilter
  }

  export type EnumRoleNullableWithAggregatesFilter = {
    equals?: Role | null
    in?: Enumerable<Role> | null
    notIn?: Enumerable<Role> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter | Role | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumRoleNullableFilter
    _max?: NestedEnumRoleNullableFilter
  }

  export type UserCreateNestedManyWithoutFriendsOfInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsOfInput>, Enumerable<UserUncheckedCreateWithoutFriendsOfInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsOfInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutFriendsInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsInput>, Enumerable<UserUncheckedCreateWithoutFriendsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutLikedByInput = {
    create?: XOR<Enumerable<MessageCreateWithoutLikedByInput>, Enumerable<MessageUncheckedCreateWithoutLikedByInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutLikedByInput>
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type ChatCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<ChatCreateWithoutCreatedByInput>, Enumerable<ChatUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<ChatCreateOrConnectWithoutCreatedByInput>
    createMany?: ChatCreateManyCreatedByInputEnvelope
    connect?: Enumerable<ChatWhereUniqueInput>
  }

  export type AlertCreateNestedManyWithoutRecipientsInput = {
    create?: XOR<Enumerable<AlertCreateWithoutRecipientsInput>, Enumerable<AlertUncheckedCreateWithoutRecipientsInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutRecipientsInput>
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type AlertCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<AlertCreateWithoutCreatedByInput>, Enumerable<AlertUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutCreatedByInput>
    createMany?: AlertCreateManyCreatedByInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type RequestCreateNestedManyWithoutRecipientInput = {
    create?: XOR<Enumerable<RequestCreateWithoutRecipientInput>, Enumerable<RequestUncheckedCreateWithoutRecipientInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutRecipientInput>
    createMany?: RequestCreateManyRecipientInputEnvelope
    connect?: Enumerable<RequestWhereUniqueInput>
  }

  export type RequestCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RequestCreateWithoutCreatedByInput>, Enumerable<RequestUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutCreatedByInput>
    createMany?: RequestCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RequestWhereUniqueInput>
  }

  export type EventCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<EventCreateWithoutCreatedByInput>, Enumerable<EventUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCreatedByInput>
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type MemberCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MemberCreateWithoutUserInput>, Enumerable<MemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutUserInput>
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type MemberCreateNestedManyWithoutAddedByInput = {
    create?: XOR<Enumerable<MemberCreateWithoutAddedByInput>, Enumerable<MemberUncheckedCreateWithoutAddedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutAddedByInput>
    createMany?: MemberCreateManyAddedByInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type MemberCreateNestedManyWithoutRemovedByInput = {
    create?: XOR<Enumerable<MemberCreateWithoutRemovedByInput>, Enumerable<MemberUncheckedCreateWithoutRemovedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutRemovedByInput>
    createMany?: MemberCreateManyRemovedByInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutFriendsOfInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsOfInput>, Enumerable<UserUncheckedCreateWithoutFriendsOfInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsOfInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutFriendsInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsInput>, Enumerable<UserUncheckedCreateWithoutFriendsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutLikedByInput = {
    create?: XOR<Enumerable<MessageCreateWithoutLikedByInput>, Enumerable<MessageUncheckedCreateWithoutLikedByInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutLikedByInput>
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type ChatUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<ChatCreateWithoutCreatedByInput>, Enumerable<ChatUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<ChatCreateOrConnectWithoutCreatedByInput>
    createMany?: ChatCreateManyCreatedByInputEnvelope
    connect?: Enumerable<ChatWhereUniqueInput>
  }

  export type AlertUncheckedCreateNestedManyWithoutRecipientsInput = {
    create?: XOR<Enumerable<AlertCreateWithoutRecipientsInput>, Enumerable<AlertUncheckedCreateWithoutRecipientsInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutRecipientsInput>
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type AlertUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<AlertCreateWithoutCreatedByInput>, Enumerable<AlertUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutCreatedByInput>
    createMany?: AlertCreateManyCreatedByInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type RequestUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<Enumerable<RequestCreateWithoutRecipientInput>, Enumerable<RequestUncheckedCreateWithoutRecipientInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutRecipientInput>
    createMany?: RequestCreateManyRecipientInputEnvelope
    connect?: Enumerable<RequestWhereUniqueInput>
  }

  export type RequestUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<RequestCreateWithoutCreatedByInput>, Enumerable<RequestUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutCreatedByInput>
    createMany?: RequestCreateManyCreatedByInputEnvelope
    connect?: Enumerable<RequestWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<Enumerable<EventCreateWithoutCreatedByInput>, Enumerable<EventUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCreatedByInput>
    createMany?: EventCreateManyCreatedByInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type MemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<MemberCreateWithoutUserInput>, Enumerable<MemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutUserInput>
    createMany?: MemberCreateManyUserInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type MemberUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<Enumerable<MemberCreateWithoutAddedByInput>, Enumerable<MemberUncheckedCreateWithoutAddedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutAddedByInput>
    createMany?: MemberCreateManyAddedByInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type MemberUncheckedCreateNestedManyWithoutRemovedByInput = {
    create?: XOR<Enumerable<MemberCreateWithoutRemovedByInput>, Enumerable<MemberUncheckedCreateWithoutRemovedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutRemovedByInput>
    createMany?: MemberCreateManyRemovedByInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutFriendsOfNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsOfInput>, Enumerable<UserUncheckedCreateWithoutFriendsOfInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsOfInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFriendsOfInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFriendsOfInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFriendsOfInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUpdateManyWithoutFriendsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsInput>, Enumerable<UserUncheckedCreateWithoutFriendsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFriendsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFriendsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFriendsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type MessageUpdateManyWithoutLikedByNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutLikedByInput>, Enumerable<MessageUncheckedCreateWithoutLikedByInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutLikedByInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutLikedByInput>
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutLikedByInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutLikedByInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ChatUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<ChatCreateWithoutCreatedByInput>, Enumerable<ChatUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<ChatCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<ChatUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: ChatCreateManyCreatedByInputEnvelope
    set?: Enumerable<ChatWhereUniqueInput>
    disconnect?: Enumerable<ChatWhereUniqueInput>
    delete?: Enumerable<ChatWhereUniqueInput>
    connect?: Enumerable<ChatWhereUniqueInput>
    update?: Enumerable<ChatUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<ChatUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<ChatScalarWhereInput>
  }

  export type AlertUpdateManyWithoutRecipientsNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutRecipientsInput>, Enumerable<AlertUncheckedCreateWithoutRecipientsInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutRecipientsInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutRecipientsInput>
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutRecipientsInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutRecipientsInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type AlertUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutCreatedByInput>, Enumerable<AlertUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: AlertCreateManyCreatedByInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type RequestUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<Enumerable<RequestCreateWithoutRecipientInput>, Enumerable<RequestUncheckedCreateWithoutRecipientInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutRecipientInput>
    upsert?: Enumerable<RequestUpsertWithWhereUniqueWithoutRecipientInput>
    createMany?: RequestCreateManyRecipientInputEnvelope
    set?: Enumerable<RequestWhereUniqueInput>
    disconnect?: Enumerable<RequestWhereUniqueInput>
    delete?: Enumerable<RequestWhereUniqueInput>
    connect?: Enumerable<RequestWhereUniqueInput>
    update?: Enumerable<RequestUpdateWithWhereUniqueWithoutRecipientInput>
    updateMany?: Enumerable<RequestUpdateManyWithWhereWithoutRecipientInput>
    deleteMany?: Enumerable<RequestScalarWhereInput>
  }

  export type RequestUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RequestCreateWithoutCreatedByInput>, Enumerable<RequestUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RequestUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RequestCreateManyCreatedByInputEnvelope
    set?: Enumerable<RequestWhereUniqueInput>
    disconnect?: Enumerable<RequestWhereUniqueInput>
    delete?: Enumerable<RequestWhereUniqueInput>
    connect?: Enumerable<RequestWhereUniqueInput>
    update?: Enumerable<RequestUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RequestUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RequestScalarWhereInput>
  }

  export type EventUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<EventCreateWithoutCreatedByInput>, Enumerable<EventUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type MemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutUserInput>, Enumerable<MemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MemberCreateManyUserInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type MemberUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutAddedByInput>, Enumerable<MemberUncheckedCreateWithoutAddedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutAddedByInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutAddedByInput>
    createMany?: MemberCreateManyAddedByInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutAddedByInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutAddedByInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type MemberUpdateManyWithoutRemovedByNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutRemovedByInput>, Enumerable<MemberUncheckedCreateWithoutRemovedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutRemovedByInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutRemovedByInput>
    createMany?: MemberCreateManyRemovedByInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutRemovedByInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutRemovedByInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutFriendsOfNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsOfInput>, Enumerable<UserUncheckedCreateWithoutFriendsOfInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsOfInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFriendsOfInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFriendsOfInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFriendsOfInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutFriendsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutFriendsInput>, Enumerable<UserUncheckedCreateWithoutFriendsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutFriendsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutFriendsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutFriendsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutFriendsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutLikedByNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutLikedByInput>, Enumerable<MessageUncheckedCreateWithoutLikedByInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutLikedByInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutLikedByInput>
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutLikedByInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutLikedByInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ChatUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<ChatCreateWithoutCreatedByInput>, Enumerable<ChatUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<ChatCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<ChatUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: ChatCreateManyCreatedByInputEnvelope
    set?: Enumerable<ChatWhereUniqueInput>
    disconnect?: Enumerable<ChatWhereUniqueInput>
    delete?: Enumerable<ChatWhereUniqueInput>
    connect?: Enumerable<ChatWhereUniqueInput>
    update?: Enumerable<ChatUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<ChatUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<ChatScalarWhereInput>
  }

  export type AlertUncheckedUpdateManyWithoutRecipientsNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutRecipientsInput>, Enumerable<AlertUncheckedCreateWithoutRecipientsInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutRecipientsInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutRecipientsInput>
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutRecipientsInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutRecipientsInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type AlertUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutCreatedByInput>, Enumerable<AlertUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: AlertCreateManyCreatedByInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type RequestUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<Enumerable<RequestCreateWithoutRecipientInput>, Enumerable<RequestUncheckedCreateWithoutRecipientInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutRecipientInput>
    upsert?: Enumerable<RequestUpsertWithWhereUniqueWithoutRecipientInput>
    createMany?: RequestCreateManyRecipientInputEnvelope
    set?: Enumerable<RequestWhereUniqueInput>
    disconnect?: Enumerable<RequestWhereUniqueInput>
    delete?: Enumerable<RequestWhereUniqueInput>
    connect?: Enumerable<RequestWhereUniqueInput>
    update?: Enumerable<RequestUpdateWithWhereUniqueWithoutRecipientInput>
    updateMany?: Enumerable<RequestUpdateManyWithWhereWithoutRecipientInput>
    deleteMany?: Enumerable<RequestScalarWhereInput>
  }

  export type RequestUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<RequestCreateWithoutCreatedByInput>, Enumerable<RequestUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<RequestCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<RequestUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: RequestCreateManyCreatedByInputEnvelope
    set?: Enumerable<RequestWhereUniqueInput>
    disconnect?: Enumerable<RequestWhereUniqueInput>
    delete?: Enumerable<RequestWhereUniqueInput>
    connect?: Enumerable<RequestWhereUniqueInput>
    update?: Enumerable<RequestUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<RequestUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<RequestScalarWhereInput>
  }

  export type EventUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<Enumerable<EventCreateWithoutCreatedByInput>, Enumerable<EventUncheckedCreateWithoutCreatedByInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutCreatedByInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutCreatedByInput>
    createMany?: EventCreateManyCreatedByInputEnvelope
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutCreatedByInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutCreatedByInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type MemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutUserInput>, Enumerable<MemberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutUserInput>
    createMany?: MemberCreateManyUserInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type MemberUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutAddedByInput>, Enumerable<MemberUncheckedCreateWithoutAddedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutAddedByInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutAddedByInput>
    createMany?: MemberCreateManyAddedByInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutAddedByInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutAddedByInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type MemberUncheckedUpdateManyWithoutRemovedByNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutRemovedByInput>, Enumerable<MemberUncheckedCreateWithoutRemovedByInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutRemovedByInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutRemovedByInput>
    createMany?: MemberCreateManyRemovedByInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutRemovedByInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutRemovedByInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRequestsInput = {
    create?: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequestsSentInput = {
    create?: XOR<UserCreateWithoutRequestsSentInput, UserUncheckedCreateWithoutRequestsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsSentInput
    connect?: UserWhereUniqueInput
  }

  export type AlertCreateNestedOneWithoutRequestInput = {
    create?: XOR<AlertCreateWithoutRequestInput, AlertUncheckedCreateWithoutRequestInput>
    connectOrCreate?: AlertCreateOrConnectWithoutRequestInput
    connect?: AlertWhereUniqueInput
  }

  export type AlertUncheckedCreateNestedOneWithoutRequestInput = {
    create?: XOR<AlertCreateWithoutRequestInput, AlertUncheckedCreateWithoutRequestInput>
    connectOrCreate?: AlertCreateOrConnectWithoutRequestInput
    connect?: AlertWhereUniqueInput
  }

  export type EnumRequestTypeFieldUpdateOperationsInput = {
    set?: RequestType
  }

  export type EnumRequestStateFieldUpdateOperationsInput = {
    set?: RequestState
  }

  export type UserUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsInput
    upsert?: UserUpsertWithoutRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestsInput, UserUncheckedUpdateWithoutRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutRequestsSentNestedInput = {
    create?: XOR<UserCreateWithoutRequestsSentInput, UserUncheckedCreateWithoutRequestsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequestsSentInput
    upsert?: UserUpsertWithoutRequestsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRequestsSentInput, UserUncheckedUpdateWithoutRequestsSentInput>
  }

  export type AlertUpdateOneWithoutRequestNestedInput = {
    create?: XOR<AlertCreateWithoutRequestInput, AlertUncheckedCreateWithoutRequestInput>
    connectOrCreate?: AlertCreateOrConnectWithoutRequestInput
    upsert?: AlertUpsertWithoutRequestInput
    disconnect?: boolean
    delete?: boolean
    connect?: AlertWhereUniqueInput
    update?: XOR<AlertUpdateWithoutRequestInput, AlertUncheckedUpdateWithoutRequestInput>
  }

  export type AlertUncheckedUpdateOneWithoutRequestNestedInput = {
    create?: XOR<AlertCreateWithoutRequestInput, AlertUncheckedCreateWithoutRequestInput>
    connectOrCreate?: AlertCreateOrConnectWithoutRequestInput
    upsert?: AlertUpsertWithoutRequestInput
    disconnect?: boolean
    delete?: boolean
    connect?: AlertWhereUniqueInput
    update?: XOR<AlertUpdateWithoutRequestInput, AlertUncheckedUpdateWithoutRequestInput>
  }

  export type UserCreateNestedManyWithoutAlertsInput = {
    create?: XOR<Enumerable<UserCreateWithoutAlertsInput>, Enumerable<UserUncheckedCreateWithoutAlertsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAlertsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutAlertsSentInput = {
    create?: XOR<UserCreateWithoutAlertsSentInput, UserUncheckedCreateWithoutAlertsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsSentInput
    connect?: UserWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutAlertsInput = {
    create?: XOR<ChatCreateWithoutAlertsInput, ChatUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ChatCreateOrConnectWithoutAlertsInput
    connect?: ChatWhereUniqueInput
  }

  export type RequestCreateNestedOneWithoutAlertInput = {
    create?: XOR<RequestCreateWithoutAlertInput, RequestUncheckedCreateWithoutAlertInput>
    connectOrCreate?: RequestCreateOrConnectWithoutAlertInput
    connect?: RequestWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutAlertsInput = {
    create?: XOR<Enumerable<UserCreateWithoutAlertsInput>, Enumerable<UserUncheckedCreateWithoutAlertsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAlertsInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: AlertType
  }

  export type UserUpdateManyWithoutAlertsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutAlertsInput>, Enumerable<UserUncheckedCreateWithoutAlertsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAlertsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutAlertsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutAlertsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutAlertsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutAlertsSentNestedInput = {
    create?: XOR<UserCreateWithoutAlertsSentInput, UserUncheckedCreateWithoutAlertsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsSentInput
    upsert?: UserUpsertWithoutAlertsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAlertsSentInput, UserUncheckedUpdateWithoutAlertsSentInput>
  }

  export type ChatUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<ChatCreateWithoutAlertsInput, ChatUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ChatCreateOrConnectWithoutAlertsInput
    upsert?: ChatUpsertWithoutAlertsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ChatWhereUniqueInput
    update?: XOR<ChatUpdateWithoutAlertsInput, ChatUncheckedUpdateWithoutAlertsInput>
  }

  export type RequestUpdateOneWithoutAlertNestedInput = {
    create?: XOR<RequestCreateWithoutAlertInput, RequestUncheckedCreateWithoutAlertInput>
    connectOrCreate?: RequestCreateOrConnectWithoutAlertInput
    upsert?: RequestUpsertWithoutAlertInput
    disconnect?: boolean
    delete?: boolean
    connect?: RequestWhereUniqueInput
    update?: XOR<RequestUpdateWithoutAlertInput, RequestUncheckedUpdateWithoutAlertInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutAlertsNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutAlertsInput>, Enumerable<UserUncheckedCreateWithoutAlertsInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutAlertsInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutAlertsInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutAlertsInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutAlertsInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutMemberOfChatsInput = {
    create?: XOR<UserCreateWithoutMemberOfChatsInput, UserUncheckedCreateWithoutMemberOfChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberOfChatsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMembersInput
    connect?: ChatWhereUniqueInput
  }

  export type ChatUpdateCreateNestedManyWithoutMembersInput = {
    create?: XOR<Enumerable<ChatUpdateCreateWithoutMembersInput>, Enumerable<ChatUpdateUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ChatUpdateCreateOrConnectWithoutMembersInput>
    connect?: Enumerable<ChatUpdateWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutMembersAddedToChatInput = {
    create?: XOR<UserCreateWithoutMembersAddedToChatInput, UserUncheckedCreateWithoutMembersAddedToChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersAddedToChatInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMembersRemovedInput = {
    create?: XOR<UserCreateWithoutMembersRemovedInput, UserUncheckedCreateWithoutMembersRemovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersRemovedInput
    connect?: UserWhereUniqueInput
  }

  export type ChatUpdateUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<Enumerable<ChatUpdateCreateWithoutMembersInput>, Enumerable<ChatUpdateUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ChatUpdateCreateOrConnectWithoutMembersInput>
    connect?: Enumerable<ChatUpdateWhereUniqueInput>
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutMemberOfChatsNestedInput = {
    create?: XOR<UserCreateWithoutMemberOfChatsInput, UserUncheckedCreateWithoutMemberOfChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMemberOfChatsInput
    upsert?: UserUpsertWithoutMemberOfChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMemberOfChatsInput, UserUncheckedUpdateWithoutMemberOfChatsInput>
  }

  export type ChatUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMembersInput
    upsert?: ChatUpsertWithoutMembersInput
    connect?: ChatWhereUniqueInput
    update?: XOR<ChatUpdateWithoutMembersInput, ChatUncheckedUpdateWithoutMembersInput>
  }

  export type ChatUpdateUpdateManyWithoutMembersNestedInput = {
    create?: XOR<Enumerable<ChatUpdateCreateWithoutMembersInput>, Enumerable<ChatUpdateUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ChatUpdateCreateOrConnectWithoutMembersInput>
    upsert?: Enumerable<ChatUpdateUpsertWithWhereUniqueWithoutMembersInput>
    set?: Enumerable<ChatUpdateWhereUniqueInput>
    disconnect?: Enumerable<ChatUpdateWhereUniqueInput>
    delete?: Enumerable<ChatUpdateWhereUniqueInput>
    connect?: Enumerable<ChatUpdateWhereUniqueInput>
    update?: Enumerable<ChatUpdateUpdateWithWhereUniqueWithoutMembersInput>
    updateMany?: Enumerable<ChatUpdateUpdateManyWithWhereWithoutMembersInput>
    deleteMany?: Enumerable<ChatUpdateScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutMembersAddedToChatNestedInput = {
    create?: XOR<UserCreateWithoutMembersAddedToChatInput, UserUncheckedCreateWithoutMembersAddedToChatInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersAddedToChatInput
    upsert?: UserUpsertWithoutMembersAddedToChatInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMembersAddedToChatInput, UserUncheckedUpdateWithoutMembersAddedToChatInput>
  }

  export type UserUpdateOneWithoutMembersRemovedNestedInput = {
    create?: XOR<UserCreateWithoutMembersRemovedInput, UserUncheckedCreateWithoutMembersRemovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembersRemovedInput
    upsert?: UserUpsertWithoutMembersRemovedInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMembersRemovedInput, UserUncheckedUpdateWithoutMembersRemovedInput>
  }

  export type ChatUpdateUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<Enumerable<ChatUpdateCreateWithoutMembersInput>, Enumerable<ChatUpdateUncheckedCreateWithoutMembersInput>>
    connectOrCreate?: Enumerable<ChatUpdateCreateOrConnectWithoutMembersInput>
    upsert?: Enumerable<ChatUpdateUpsertWithWhereUniqueWithoutMembersInput>
    set?: Enumerable<ChatUpdateWhereUniqueInput>
    disconnect?: Enumerable<ChatUpdateWhereUniqueInput>
    delete?: Enumerable<ChatUpdateWhereUniqueInput>
    connect?: Enumerable<ChatUpdateWhereUniqueInput>
    update?: Enumerable<ChatUpdateUpdateWithWhereUniqueWithoutMembersInput>
    updateMany?: Enumerable<ChatUpdateUpdateManyWithWhereWithoutMembersInput>
    deleteMany?: Enumerable<ChatUpdateScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCreatorOfChatsInput = {
    create?: XOR<UserCreateWithoutCreatorOfChatsInput, UserUncheckedCreateWithoutCreatorOfChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorOfChatsInput
    connect?: UserWhereUniqueInput
  }

  export type MemberCreateNestedManyWithoutChatInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatInput>, Enumerable<MemberUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatInput>
    createMany?: MemberCreateManyChatInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type EventCreateNestedManyWithoutChatInput = {
    create?: XOR<Enumerable<EventCreateWithoutChatInput>, Enumerable<EventUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutChatInput>
    createMany?: EventCreateManyChatInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type AlertCreateNestedManyWithoutChatInput = {
    create?: XOR<Enumerable<AlertCreateWithoutChatInput>, Enumerable<AlertUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutChatInput>
    createMany?: AlertCreateManyChatInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type MemberUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatInput>, Enumerable<MemberUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatInput>
    createMany?: MemberCreateManyChatInputEnvelope
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<Enumerable<EventCreateWithoutChatInput>, Enumerable<EventUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutChatInput>
    createMany?: EventCreateManyChatInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type AlertUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<Enumerable<AlertCreateWithoutChatInput>, Enumerable<AlertUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutChatInput>
    createMany?: AlertCreateManyChatInputEnvelope
    connect?: Enumerable<AlertWhereUniqueInput>
  }

  export type EnumChatTypeFieldUpdateOperationsInput = {
    set?: ChatType
  }

  export type UserUpdateOneRequiredWithoutCreatorOfChatsNestedInput = {
    create?: XOR<UserCreateWithoutCreatorOfChatsInput, UserUncheckedCreateWithoutCreatorOfChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatorOfChatsInput
    upsert?: UserUpsertWithoutCreatorOfChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreatorOfChatsInput, UserUncheckedUpdateWithoutCreatorOfChatsInput>
  }

  export type MemberUpdateManyWithoutChatNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatInput>, Enumerable<MemberUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutChatInput>
    createMany?: MemberCreateManyChatInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutChatInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutChatInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type EventUpdateManyWithoutChatNestedInput = {
    create?: XOR<Enumerable<EventCreateWithoutChatInput>, Enumerable<EventUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutChatInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutChatInput>
    createMany?: EventCreateManyChatInputEnvelope
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutChatInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutChatInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type AlertUpdateManyWithoutChatNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutChatInput>, Enumerable<AlertUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutChatInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutChatInput>
    createMany?: AlertCreateManyChatInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutChatInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutChatInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type MemberUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatInput>, Enumerable<MemberUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutChatInput>
    createMany?: MemberCreateManyChatInputEnvelope
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutChatInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutChatInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type EventUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<Enumerable<EventCreateWithoutChatInput>, Enumerable<EventUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutChatInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutChatInput>
    createMany?: EventCreateManyChatInputEnvelope
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    connect?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutChatInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutChatInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type AlertUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<Enumerable<AlertCreateWithoutChatInput>, Enumerable<AlertUncheckedCreateWithoutChatInput>>
    connectOrCreate?: Enumerable<AlertCreateOrConnectWithoutChatInput>
    upsert?: Enumerable<AlertUpsertWithWhereUniqueWithoutChatInput>
    createMany?: AlertCreateManyChatInputEnvelope
    set?: Enumerable<AlertWhereUniqueInput>
    disconnect?: Enumerable<AlertWhereUniqueInput>
    delete?: Enumerable<AlertWhereUniqueInput>
    connect?: Enumerable<AlertWhereUniqueInput>
    update?: Enumerable<AlertUpdateWithWhereUniqueWithoutChatInput>
    updateMany?: Enumerable<AlertUpdateManyWithWhereWithoutChatInput>
    deleteMany?: Enumerable<AlertScalarWhereInput>
  }

  export type ChatCreateNestedOneWithoutEventInput = {
    create?: XOR<ChatCreateWithoutEventInput, ChatUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChatCreateOrConnectWithoutEventInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventsCreatedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutEventInput = {
    create?: XOR<MessageCreateWithoutEventInput, MessageUncheckedCreateWithoutEventInput>
    connectOrCreate?: MessageCreateOrConnectWithoutEventInput
    connect?: MessageWhereUniqueInput
  }

  export type ChatUpdateCreateNestedOneWithoutEventInput = {
    create?: XOR<ChatUpdateCreateWithoutEventInput, ChatUpdateUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChatUpdateCreateOrConnectWithoutEventInput
    connect?: ChatUpdateWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<MessageCreateWithoutEventInput, MessageUncheckedCreateWithoutEventInput>
    connectOrCreate?: MessageCreateOrConnectWithoutEventInput
    connect?: MessageWhereUniqueInput
  }

  export type ChatUpdateUncheckedCreateNestedOneWithoutEventInput = {
    create?: XOR<ChatUpdateCreateWithoutEventInput, ChatUpdateUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChatUpdateCreateOrConnectWithoutEventInput
    connect?: ChatUpdateWhereUniqueInput
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: EventType
  }

  export type ChatUpdateOneRequiredWithoutEventNestedInput = {
    create?: XOR<ChatCreateWithoutEventInput, ChatUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChatCreateOrConnectWithoutEventInput
    upsert?: ChatUpsertWithoutEventInput
    connect?: ChatWhereUniqueInput
    update?: XOR<ChatUpdateWithoutEventInput, ChatUncheckedUpdateWithoutEventInput>
  }

  export type UserUpdateOneRequiredWithoutEventsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    upsert?: UserUpsertWithoutEventsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
  }

  export type MessageUpdateOneWithoutEventNestedInput = {
    create?: XOR<MessageCreateWithoutEventInput, MessageUncheckedCreateWithoutEventInput>
    connectOrCreate?: MessageCreateOrConnectWithoutEventInput
    upsert?: MessageUpsertWithoutEventInput
    disconnect?: boolean
    delete?: boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<MessageUpdateWithoutEventInput, MessageUncheckedUpdateWithoutEventInput>
  }

  export type ChatUpdateUpdateOneWithoutEventNestedInput = {
    create?: XOR<ChatUpdateCreateWithoutEventInput, ChatUpdateUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChatUpdateCreateOrConnectWithoutEventInput
    upsert?: ChatUpdateUpsertWithoutEventInput
    disconnect?: boolean
    delete?: boolean
    connect?: ChatUpdateWhereUniqueInput
    update?: XOR<ChatUpdateUpdateWithoutEventInput, ChatUpdateUncheckedUpdateWithoutEventInput>
  }

  export type MessageUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<MessageCreateWithoutEventInput, MessageUncheckedCreateWithoutEventInput>
    connectOrCreate?: MessageCreateOrConnectWithoutEventInput
    upsert?: MessageUpsertWithoutEventInput
    disconnect?: boolean
    delete?: boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<MessageUpdateWithoutEventInput, MessageUncheckedUpdateWithoutEventInput>
  }

  export type ChatUpdateUncheckedUpdateOneWithoutEventNestedInput = {
    create?: XOR<ChatUpdateCreateWithoutEventInput, ChatUpdateUncheckedCreateWithoutEventInput>
    connectOrCreate?: ChatUpdateCreateOrConnectWithoutEventInput
    upsert?: ChatUpdateUpsertWithoutEventInput
    disconnect?: boolean
    delete?: boolean
    connect?: ChatUpdateWhereUniqueInput
    update?: XOR<ChatUpdateUpdateWithoutEventInput, ChatUpdateUncheckedUpdateWithoutEventInput>
  }

  export type EventCreateNestedOneWithoutMessageInput = {
    create?: XOR<EventCreateWithoutMessageInput, EventUncheckedCreateWithoutMessageInput>
    connectOrCreate?: EventCreateOrConnectWithoutMessageInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutLikedMessagesInput = {
    create?: XOR<Enumerable<UserCreateWithoutLikedMessagesInput>, Enumerable<UserUncheckedCreateWithoutLikedMessagesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLikedMessagesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutLikedMessagesInput = {
    create?: XOR<Enumerable<UserCreateWithoutLikedMessagesInput>, Enumerable<UserUncheckedCreateWithoutLikedMessagesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLikedMessagesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type EventUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<EventCreateWithoutMessageInput, EventUncheckedCreateWithoutMessageInput>
    connectOrCreate?: EventCreateOrConnectWithoutMessageInput
    upsert?: EventUpsertWithoutMessageInput
    connect?: EventWhereUniqueInput
    update?: XOR<EventUpdateWithoutMessageInput, EventUncheckedUpdateWithoutMessageInput>
  }

  export type UserUpdateManyWithoutLikedMessagesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutLikedMessagesInput>, Enumerable<UserUncheckedCreateWithoutLikedMessagesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLikedMessagesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLikedMessagesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLikedMessagesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLikedMessagesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutLikedMessagesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutLikedMessagesInput>, Enumerable<UserUncheckedCreateWithoutLikedMessagesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutLikedMessagesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutLikedMessagesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutLikedMessagesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutLikedMessagesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type EventCreateNestedOneWithoutChatUpdateInput = {
    create?: XOR<EventCreateWithoutChatUpdateInput, EventUncheckedCreateWithoutChatUpdateInput>
    connectOrCreate?: EventCreateOrConnectWithoutChatUpdateInput
    connect?: EventWhereUniqueInput
  }

  export type MemberCreateNestedManyWithoutChatUpdatesInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatUpdatesInput>, Enumerable<MemberUncheckedCreateWithoutChatUpdatesInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatUpdatesInput>
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type MemberUncheckedCreateNestedManyWithoutChatUpdatesInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatUpdatesInput>, Enumerable<MemberUncheckedCreateWithoutChatUpdatesInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatUpdatesInput>
    connect?: Enumerable<MemberWhereUniqueInput>
  }

  export type EnumChatUpdateTypeFieldUpdateOperationsInput = {
    set?: ChatUpdateType
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: Role | null
  }

  export type EventUpdateOneRequiredWithoutChatUpdateNestedInput = {
    create?: XOR<EventCreateWithoutChatUpdateInput, EventUncheckedCreateWithoutChatUpdateInput>
    connectOrCreate?: EventCreateOrConnectWithoutChatUpdateInput
    upsert?: EventUpsertWithoutChatUpdateInput
    connect?: EventWhereUniqueInput
    update?: XOR<EventUpdateWithoutChatUpdateInput, EventUncheckedUpdateWithoutChatUpdateInput>
  }

  export type MemberUpdateManyWithoutChatUpdatesNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatUpdatesInput>, Enumerable<MemberUncheckedCreateWithoutChatUpdatesInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatUpdatesInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutChatUpdatesInput>
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutChatUpdatesInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutChatUpdatesInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type MemberUncheckedUpdateManyWithoutChatUpdatesNestedInput = {
    create?: XOR<Enumerable<MemberCreateWithoutChatUpdatesInput>, Enumerable<MemberUncheckedCreateWithoutChatUpdatesInput>>
    connectOrCreate?: Enumerable<MemberCreateOrConnectWithoutChatUpdatesInput>
    upsert?: Enumerable<MemberUpsertWithWhereUniqueWithoutChatUpdatesInput>
    set?: Enumerable<MemberWhereUniqueInput>
    disconnect?: Enumerable<MemberWhereUniqueInput>
    delete?: Enumerable<MemberWhereUniqueInput>
    connect?: Enumerable<MemberWhereUniqueInput>
    update?: Enumerable<MemberUpdateWithWhereUniqueWithoutChatUpdatesInput>
    updateMany?: Enumerable<MemberUpdateManyWithWhereWithoutChatUpdatesInput>
    deleteMany?: Enumerable<MemberScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumRequestTypeFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeFilter | RequestType
  }

  export type NestedEnumRequestStateFilter = {
    equals?: RequestState
    in?: Enumerable<RequestState>
    notIn?: Enumerable<RequestState>
    not?: NestedEnumRequestStateFilter | RequestState
  }

  export type NestedEnumRequestTypeWithAggregatesFilter = {
    equals?: RequestType
    in?: Enumerable<RequestType>
    notIn?: Enumerable<RequestType>
    not?: NestedEnumRequestTypeWithAggregatesFilter | RequestType
    _count?: NestedIntFilter
    _min?: NestedEnumRequestTypeFilter
    _max?: NestedEnumRequestTypeFilter
  }

  export type NestedEnumRequestStateWithAggregatesFilter = {
    equals?: RequestState
    in?: Enumerable<RequestState>
    notIn?: Enumerable<RequestState>
    not?: NestedEnumRequestStateWithAggregatesFilter | RequestState
    _count?: NestedIntFilter
    _min?: NestedEnumRequestStateFilter
    _max?: NestedEnumRequestStateFilter
  }

  export type NestedEnumAlertTypeFilter = {
    equals?: AlertType
    in?: Enumerable<AlertType>
    notIn?: Enumerable<AlertType>
    not?: NestedEnumAlertTypeFilter | AlertType
  }

  export type NestedEnumAlertTypeWithAggregatesFilter = {
    equals?: AlertType
    in?: Enumerable<AlertType>
    notIn?: Enumerable<AlertType>
    not?: NestedEnumAlertTypeWithAggregatesFilter | AlertType
    _count?: NestedIntFilter
    _min?: NestedEnumAlertTypeFilter
    _max?: NestedEnumAlertTypeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumChatTypeFilter = {
    equals?: ChatType
    in?: Enumerable<ChatType>
    notIn?: Enumerable<ChatType>
    not?: NestedEnumChatTypeFilter | ChatType
  }

  export type NestedEnumChatTypeWithAggregatesFilter = {
    equals?: ChatType
    in?: Enumerable<ChatType>
    notIn?: Enumerable<ChatType>
    not?: NestedEnumChatTypeWithAggregatesFilter | ChatType
    _count?: NestedIntFilter
    _min?: NestedEnumChatTypeFilter
    _max?: NestedEnumChatTypeFilter
  }

  export type NestedEnumEventTypeFilter = {
    equals?: EventType
    in?: Enumerable<EventType>
    notIn?: Enumerable<EventType>
    not?: NestedEnumEventTypeFilter | EventType
  }

  export type NestedEnumEventTypeWithAggregatesFilter = {
    equals?: EventType
    in?: Enumerable<EventType>
    notIn?: Enumerable<EventType>
    not?: NestedEnumEventTypeWithAggregatesFilter | EventType
    _count?: NestedIntFilter
    _min?: NestedEnumEventTypeFilter
    _max?: NestedEnumEventTypeFilter
  }

  export type NestedEnumChatUpdateTypeFilter = {
    equals?: ChatUpdateType
    in?: Enumerable<ChatUpdateType>
    notIn?: Enumerable<ChatUpdateType>
    not?: NestedEnumChatUpdateTypeFilter | ChatUpdateType
  }

  export type NestedEnumRoleNullableFilter = {
    equals?: Role | null
    in?: Enumerable<Role> | null
    notIn?: Enumerable<Role> | null
    not?: NestedEnumRoleNullableFilter | Role | null
  }

  export type NestedEnumChatUpdateTypeWithAggregatesFilter = {
    equals?: ChatUpdateType
    in?: Enumerable<ChatUpdateType>
    notIn?: Enumerable<ChatUpdateType>
    not?: NestedEnumChatUpdateTypeWithAggregatesFilter | ChatUpdateType
    _count?: NestedIntFilter
    _min?: NestedEnumChatUpdateTypeFilter
    _max?: NestedEnumChatUpdateTypeFilter
  }

  export type NestedEnumRoleNullableWithAggregatesFilter = {
    equals?: Role | null
    in?: Enumerable<Role> | null
    notIn?: Enumerable<Role> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter | Role | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumRoleNullableFilter
    _max?: NestedEnumRoleNullableFilter
  }

  export type UserCreateWithoutFriendsOfInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutFriendsOfInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutFriendsOfInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendsOfInput, UserUncheckedCreateWithoutFriendsOfInput>
  }

  export type UserCreateWithoutFriendsInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutFriendsInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutFriendsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
  }

  export type MessageCreateWithoutLikedByInput = {
    content: string
    event: EventCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutLikedByInput = {
    eventId: number
    content: string
  }

  export type MessageCreateOrConnectWithoutLikedByInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutLikedByInput, MessageUncheckedCreateWithoutLikedByInput>
  }

  export type ChatCreateWithoutCreatedByInput = {
    type: ChatType
    name?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    members?: MemberCreateNestedManyWithoutChatInput
    event?: EventCreateNestedManyWithoutChatInput
    alerts?: AlertCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutCreatedByInput = {
    id?: number
    type: ChatType
    name?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutChatInput
    event?: EventUncheckedCreateNestedManyWithoutChatInput
    alerts?: AlertUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutCreatedByInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutCreatedByInput, ChatUncheckedCreateWithoutCreatedByInput>
  }

  export type ChatCreateManyCreatedByInputEnvelope = {
    data: Enumerable<ChatCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutRecipientsInput = {
    type: AlertType
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutAlertsSentInput
    chat?: ChatCreateNestedOneWithoutAlertsInput
    request?: RequestCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutRecipientsInput = {
    id?: number
    type: AlertType
    createdById: number
    createdAt?: Date | string
    chatId?: number | null
    requestId?: number | null
  }

  export type AlertCreateOrConnectWithoutRecipientsInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutRecipientsInput, AlertUncheckedCreateWithoutRecipientsInput>
  }

  export type AlertCreateWithoutCreatedByInput = {
    type: AlertType
    createdAt?: Date | string
    recipients?: UserCreateNestedManyWithoutAlertsInput
    chat?: ChatCreateNestedOneWithoutAlertsInput
    request?: RequestCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutCreatedByInput = {
    id?: number
    type: AlertType
    createdAt?: Date | string
    chatId?: number | null
    requestId?: number | null
    recipients?: UserUncheckedCreateNestedManyWithoutAlertsInput
  }

  export type AlertCreateOrConnectWithoutCreatedByInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutCreatedByInput, AlertUncheckedCreateWithoutCreatedByInput>
  }

  export type AlertCreateManyCreatedByInputEnvelope = {
    data: Enumerable<AlertCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutRecipientInput = {
    type: RequestType
    state?: RequestState
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutRequestsSentInput
    alert?: AlertCreateNestedOneWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutRecipientInput = {
    id?: number
    type: RequestType
    state?: RequestState
    createdById: number
    createdAt?: Date | string
    alert?: AlertUncheckedCreateNestedOneWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutRecipientInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutRecipientInput, RequestUncheckedCreateWithoutRecipientInput>
  }

  export type RequestCreateManyRecipientInputEnvelope = {
    data: Enumerable<RequestCreateManyRecipientInput>
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutCreatedByInput = {
    type: RequestType
    state?: RequestState
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutRequestsInput
    alert?: AlertCreateNestedOneWithoutRequestInput
  }

  export type RequestUncheckedCreateWithoutCreatedByInput = {
    id?: number
    type: RequestType
    state?: RequestState
    recipientId: number
    createdAt?: Date | string
    alert?: AlertUncheckedCreateNestedOneWithoutRequestInput
  }

  export type RequestCreateOrConnectWithoutCreatedByInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutCreatedByInput, RequestUncheckedCreateWithoutCreatedByInput>
  }

  export type RequestCreateManyCreatedByInputEnvelope = {
    data: Enumerable<RequestCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatedByInput = {
    type: EventType
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    chat: ChatCreateNestedOneWithoutEventInput
    message?: MessageCreateNestedOneWithoutEventInput
    chatUpdate?: ChatUpdateCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCreatedByInput = {
    id?: number
    type: EventType
    chatId: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    message?: MessageUncheckedCreateNestedOneWithoutEventInput
    chatUpdate?: ChatUpdateUncheckedCreateNestedOneWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventCreateManyCreatedByInputEnvelope = {
    data: Enumerable<EventCreateManyCreatedByInput>
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutUserInput = {
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    chat: ChatCreateNestedOneWithoutMembersInput
    chatUpdates?: ChatUpdateCreateNestedManyWithoutMembersInput
    addedBy: UserCreateNestedOneWithoutMembersAddedToChatInput
    removedBy?: UserCreateNestedOneWithoutMembersRemovedInput
  }

  export type MemberUncheckedCreateWithoutUserInput = {
    id?: number
    chatId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
    chatUpdates?: ChatUpdateUncheckedCreateNestedManyWithoutMembersInput
  }

  export type MemberCreateOrConnectWithoutUserInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberCreateManyUserInputEnvelope = {
    data: Enumerable<MemberCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutAddedByInput = {
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMemberOfChatsInput
    chat: ChatCreateNestedOneWithoutMembersInput
    chatUpdates?: ChatUpdateCreateNestedManyWithoutMembersInput
    removedBy?: UserCreateNestedOneWithoutMembersRemovedInput
  }

  export type MemberUncheckedCreateWithoutAddedByInput = {
    id?: number
    userId: number
    chatId: number
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
    chatUpdates?: ChatUpdateUncheckedCreateNestedManyWithoutMembersInput
  }

  export type MemberCreateOrConnectWithoutAddedByInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutAddedByInput, MemberUncheckedCreateWithoutAddedByInput>
  }

  export type MemberCreateManyAddedByInputEnvelope = {
    data: Enumerable<MemberCreateManyAddedByInput>
    skipDuplicates?: boolean
  }

  export type MemberCreateWithoutRemovedByInput = {
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMemberOfChatsInput
    chat: ChatCreateNestedOneWithoutMembersInput
    chatUpdates?: ChatUpdateCreateNestedManyWithoutMembersInput
    addedBy: UserCreateNestedOneWithoutMembersAddedToChatInput
  }

  export type MemberUncheckedCreateWithoutRemovedByInput = {
    id?: number
    userId: number
    chatId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    chatUpdates?: ChatUpdateUncheckedCreateNestedManyWithoutMembersInput
  }

  export type MemberCreateOrConnectWithoutRemovedByInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutRemovedByInput, MemberUncheckedCreateWithoutRemovedByInput>
  }

  export type MemberCreateManyRemovedByInputEnvelope = {
    data: Enumerable<MemberCreateManyRemovedByInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutFriendsOfInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFriendsOfInput, UserUncheckedUpdateWithoutFriendsOfInput>
    create: XOR<UserCreateWithoutFriendsOfInput, UserUncheckedCreateWithoutFriendsOfInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFriendsOfInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFriendsOfInput, UserUncheckedUpdateWithoutFriendsOfInput>
  }

  export type UserUpdateManyWithWhereWithoutFriendsOfInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFriendsInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    name?: StringNullableFilter | string | null
    username?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutFriendsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFriendsInput, UserUncheckedUpdateWithoutFriendsInput>
    create: XOR<UserCreateWithoutFriendsInput, UserUncheckedCreateWithoutFriendsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFriendsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFriendsInput, UserUncheckedUpdateWithoutFriendsInput>
  }

  export type UserUpdateManyWithWhereWithoutFriendsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFriendsOfInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutLikedByInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutLikedByInput, MessageUncheckedUpdateWithoutLikedByInput>
    create: XOR<MessageCreateWithoutLikedByInput, MessageUncheckedCreateWithoutLikedByInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutLikedByInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutLikedByInput, MessageUncheckedUpdateWithoutLikedByInput>
  }

  export type MessageUpdateManyWithWhereWithoutLikedByInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutLikedMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    eventId?: IntFilter | number
    content?: StringFilter | string
  }

  export type ChatUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutCreatedByInput, ChatUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ChatCreateWithoutCreatedByInput, ChatUncheckedCreateWithoutCreatedByInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutCreatedByInput, ChatUncheckedUpdateWithoutCreatedByInput>
  }

  export type ChatUpdateManyWithWhereWithoutCreatedByInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutCreatorOfChatsInput>
  }

  export type ChatScalarWhereInput = {
    AND?: Enumerable<ChatScalarWhereInput>
    OR?: Enumerable<ChatScalarWhereInput>
    NOT?: Enumerable<ChatScalarWhereInput>
    id?: IntFilter | number
    type?: EnumChatTypeFilter | ChatType
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    createdById?: IntFilter | number
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type AlertUpsertWithWhereUniqueWithoutRecipientsInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutRecipientsInput, AlertUncheckedUpdateWithoutRecipientsInput>
    create: XOR<AlertCreateWithoutRecipientsInput, AlertUncheckedCreateWithoutRecipientsInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutRecipientsInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutRecipientsInput, AlertUncheckedUpdateWithoutRecipientsInput>
  }

  export type AlertUpdateManyWithWhereWithoutRecipientsInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutAlertsInput>
  }

  export type AlertScalarWhereInput = {
    AND?: Enumerable<AlertScalarWhereInput>
    OR?: Enumerable<AlertScalarWhereInput>
    NOT?: Enumerable<AlertScalarWhereInput>
    id?: IntFilter | number
    type?: EnumAlertTypeFilter | AlertType
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    chatId?: IntNullableFilter | number | null
    requestId?: IntNullableFilter | number | null
  }

  export type AlertUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutCreatedByInput, AlertUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AlertCreateWithoutCreatedByInput, AlertUncheckedCreateWithoutCreatedByInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutCreatedByInput, AlertUncheckedUpdateWithoutCreatedByInput>
  }

  export type AlertUpdateManyWithWhereWithoutCreatedByInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutAlertsSentInput>
  }

  export type RequestUpsertWithWhereUniqueWithoutRecipientInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutRecipientInput, RequestUncheckedUpdateWithoutRecipientInput>
    create: XOR<RequestCreateWithoutRecipientInput, RequestUncheckedCreateWithoutRecipientInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutRecipientInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutRecipientInput, RequestUncheckedUpdateWithoutRecipientInput>
  }

  export type RequestUpdateManyWithWhereWithoutRecipientInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutRequestsInput>
  }

  export type RequestScalarWhereInput = {
    AND?: Enumerable<RequestScalarWhereInput>
    OR?: Enumerable<RequestScalarWhereInput>
    NOT?: Enumerable<RequestScalarWhereInput>
    id?: IntFilter | number
    type?: EnumRequestTypeFilter | RequestType
    state?: EnumRequestStateFilter | RequestState
    recipientId?: IntFilter | number
    createdById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
  }

  export type RequestUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutCreatedByInput, RequestUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RequestCreateWithoutCreatedByInput, RequestUncheckedCreateWithoutCreatedByInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutCreatedByInput, RequestUncheckedUpdateWithoutCreatedByInput>
  }

  export type RequestUpdateManyWithWhereWithoutCreatedByInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutRequestsSentInput>
  }

  export type EventUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EventCreateWithoutCreatedByInput, EventUncheckedCreateWithoutCreatedByInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatedByInput, EventUncheckedUpdateWithoutCreatedByInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatedByInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEventsCreatedInput>
  }

  export type EventScalarWhereInput = {
    AND?: Enumerable<EventScalarWhereInput>
    OR?: Enumerable<EventScalarWhereInput>
    NOT?: Enumerable<EventScalarWhereInput>
    id?: IntFilter | number
    type?: EnumEventTypeFilter | EventType
    chatId?: IntFilter | number
    createdById?: IntFilter | number
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type MemberUpsertWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
    create: XOR<MemberCreateWithoutUserInput, MemberUncheckedCreateWithoutUserInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutUserInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutUserInput, MemberUncheckedUpdateWithoutUserInput>
  }

  export type MemberUpdateManyWithWhereWithoutUserInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMemberOfChatsInput>
  }

  export type MemberScalarWhereInput = {
    AND?: Enumerable<MemberScalarWhereInput>
    OR?: Enumerable<MemberScalarWhereInput>
    NOT?: Enumerable<MemberScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    chatId?: IntFilter | number
    role?: EnumRoleFilter | Role
    addedById?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    removedAt?: DateTimeNullableFilter | Date | string | null
    removedById?: IntNullableFilter | number | null
  }

  export type MemberUpsertWithWhereUniqueWithoutAddedByInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutAddedByInput, MemberUncheckedUpdateWithoutAddedByInput>
    create: XOR<MemberCreateWithoutAddedByInput, MemberUncheckedCreateWithoutAddedByInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutAddedByInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutAddedByInput, MemberUncheckedUpdateWithoutAddedByInput>
  }

  export type MemberUpdateManyWithWhereWithoutAddedByInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMembersAddedToChatInput>
  }

  export type MemberUpsertWithWhereUniqueWithoutRemovedByInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutRemovedByInput, MemberUncheckedUpdateWithoutRemovedByInput>
    create: XOR<MemberCreateWithoutRemovedByInput, MemberUncheckedCreateWithoutRemovedByInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutRemovedByInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutRemovedByInput, MemberUncheckedUpdateWithoutRemovedByInput>
  }

  export type MemberUpdateManyWithWhereWithoutRemovedByInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMembersRemovedInput>
  }

  export type UserCreateWithoutRequestsInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutRequestsInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
  }

  export type UserCreateWithoutRequestsSentInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutRequestsSentInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutRequestsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequestsSentInput, UserUncheckedCreateWithoutRequestsSentInput>
  }

  export type AlertCreateWithoutRequestInput = {
    type: AlertType
    createdAt?: Date | string
    recipients?: UserCreateNestedManyWithoutAlertsInput
    createdBy: UserCreateNestedOneWithoutAlertsSentInput
    chat?: ChatCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutRequestInput = {
    id?: number
    type: AlertType
    createdById: number
    createdAt?: Date | string
    chatId?: number | null
    recipients?: UserUncheckedCreateNestedManyWithoutAlertsInput
  }

  export type AlertCreateOrConnectWithoutRequestInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutRequestInput, AlertUncheckedCreateWithoutRequestInput>
  }

  export type UserUpsertWithoutRequestsInput = {
    update: XOR<UserUpdateWithoutRequestsInput, UserUncheckedUpdateWithoutRequestsInput>
    create: XOR<UserCreateWithoutRequestsInput, UserUncheckedCreateWithoutRequestsInput>
  }

  export type UserUpdateWithoutRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUpsertWithoutRequestsSentInput = {
    update: XOR<UserUpdateWithoutRequestsSentInput, UserUncheckedUpdateWithoutRequestsSentInput>
    create: XOR<UserCreateWithoutRequestsSentInput, UserUncheckedCreateWithoutRequestsSentInput>
  }

  export type UserUpdateWithoutRequestsSentInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRequestsSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type AlertUpsertWithoutRequestInput = {
    update: XOR<AlertUpdateWithoutRequestInput, AlertUncheckedUpdateWithoutRequestInput>
    create: XOR<AlertCreateWithoutRequestInput, AlertUncheckedCreateWithoutRequestInput>
  }

  export type AlertUpdateWithoutRequestInput = {
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUpdateManyWithoutAlertsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAlertsSentNestedInput
    chat?: ChatUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: UserUncheckedUpdateManyWithoutAlertsNestedInput
  }

  export type UserCreateWithoutAlertsInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type UserCreateWithoutAlertsSentInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutAlertsSentInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutAlertsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsSentInput, UserUncheckedCreateWithoutAlertsSentInput>
  }

  export type ChatCreateWithoutAlertsInput = {
    type: ChatType
    name?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatorOfChatsInput
    members?: MemberCreateNestedManyWithoutChatInput
    event?: EventCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutAlertsInput = {
    id?: number
    type: ChatType
    name?: string | null
    description?: string | null
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutChatInput
    event?: EventUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutAlertsInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutAlertsInput, ChatUncheckedCreateWithoutAlertsInput>
  }

  export type RequestCreateWithoutAlertInput = {
    type: RequestType
    state?: RequestState
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutRequestsInput
    createdBy: UserCreateNestedOneWithoutRequestsSentInput
  }

  export type RequestUncheckedCreateWithoutAlertInput = {
    id?: number
    type: RequestType
    state?: RequestState
    recipientId: number
    createdById: number
    createdAt?: Date | string
  }

  export type RequestCreateOrConnectWithoutAlertInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutAlertInput, RequestUncheckedCreateWithoutAlertInput>
  }

  export type UserUpsertWithWhereUniqueWithoutAlertsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAlertsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateManyWithWhereWithoutAlertsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRecipientsInput>
  }

  export type UserUpsertWithoutAlertsSentInput = {
    update: XOR<UserUpdateWithoutAlertsSentInput, UserUncheckedUpdateWithoutAlertsSentInput>
    create: XOR<UserCreateWithoutAlertsSentInput, UserUncheckedCreateWithoutAlertsSentInput>
  }

  export type UserUpdateWithoutAlertsSentInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type ChatUpsertWithoutAlertsInput = {
    update: XOR<ChatUpdateWithoutAlertsInput, ChatUncheckedUpdateWithoutAlertsInput>
    create: XOR<ChatCreateWithoutAlertsInput, ChatUncheckedCreateWithoutAlertsInput>
  }

  export type ChatUpdateWithoutAlertsInput = {
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatorOfChatsNestedInput
    members?: MemberUpdateManyWithoutChatNestedInput
    event?: EventUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutChatNestedInput
    event?: EventUncheckedUpdateManyWithoutChatNestedInput
  }

  export type RequestUpsertWithoutAlertInput = {
    update: XOR<RequestUpdateWithoutAlertInput, RequestUncheckedUpdateWithoutAlertInput>
    create: XOR<RequestCreateWithoutAlertInput, RequestUncheckedCreateWithoutAlertInput>
  }

  export type RequestUpdateWithoutAlertInput = {
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutRequestsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutRequestsSentNestedInput
  }

  export type RequestUncheckedUpdateWithoutAlertInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    recipientId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutMemberOfChatsInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutMemberOfChatsInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutMemberOfChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMemberOfChatsInput, UserUncheckedCreateWithoutMemberOfChatsInput>
  }

  export type ChatCreateWithoutMembersInput = {
    type: ChatType
    name?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatorOfChatsInput
    event?: EventCreateNestedManyWithoutChatInput
    alerts?: AlertCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMembersInput = {
    id?: number
    type: ChatType
    name?: string | null
    description?: string | null
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    event?: EventUncheckedCreateNestedManyWithoutChatInput
    alerts?: AlertUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutMembersInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
  }

  export type ChatUpdateCreateWithoutMembersInput = {
    type: ChatUpdateType
    nameBefore?: string | null
    nameAfter?: string | null
    descriptionBefore?: string | null
    descriptionAfter?: string | null
    newRole?: Role | null
    event: EventCreateNestedOneWithoutChatUpdateInput
  }

  export type ChatUpdateUncheckedCreateWithoutMembersInput = {
    eventId: number
    type: ChatUpdateType
    nameBefore?: string | null
    nameAfter?: string | null
    descriptionBefore?: string | null
    descriptionAfter?: string | null
    newRole?: Role | null
  }

  export type ChatUpdateCreateOrConnectWithoutMembersInput = {
    where: ChatUpdateWhereUniqueInput
    create: XOR<ChatUpdateCreateWithoutMembersInput, ChatUpdateUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutMembersAddedToChatInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutMembersAddedToChatInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutMembersAddedToChatInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembersAddedToChatInput, UserUncheckedCreateWithoutMembersAddedToChatInput>
  }

  export type UserCreateWithoutMembersRemovedInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
  }

  export type UserUncheckedCreateWithoutMembersRemovedInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type UserCreateOrConnectWithoutMembersRemovedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembersRemovedInput, UserUncheckedCreateWithoutMembersRemovedInput>
  }

  export type UserUpsertWithoutMemberOfChatsInput = {
    update: XOR<UserUpdateWithoutMemberOfChatsInput, UserUncheckedUpdateWithoutMemberOfChatsInput>
    create: XOR<UserCreateWithoutMemberOfChatsInput, UserUncheckedCreateWithoutMemberOfChatsInput>
  }

  export type UserUpdateWithoutMemberOfChatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMemberOfChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type ChatUpsertWithoutMembersInput = {
    update: XOR<ChatUpdateWithoutMembersInput, ChatUncheckedUpdateWithoutMembersInput>
    create: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
  }

  export type ChatUpdateWithoutMembersInput = {
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatorOfChatsNestedInput
    event?: EventUpdateManyWithoutChatNestedInput
    alerts?: AlertUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUncheckedUpdateManyWithoutChatNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUpdateUpsertWithWhereUniqueWithoutMembersInput = {
    where: ChatUpdateWhereUniqueInput
    update: XOR<ChatUpdateUpdateWithoutMembersInput, ChatUpdateUncheckedUpdateWithoutMembersInput>
    create: XOR<ChatUpdateCreateWithoutMembersInput, ChatUpdateUncheckedCreateWithoutMembersInput>
  }

  export type ChatUpdateUpdateWithWhereUniqueWithoutMembersInput = {
    where: ChatUpdateWhereUniqueInput
    data: XOR<ChatUpdateUpdateWithoutMembersInput, ChatUpdateUncheckedUpdateWithoutMembersInput>
  }

  export type ChatUpdateUpdateManyWithWhereWithoutMembersInput = {
    where: ChatUpdateScalarWhereInput
    data: XOR<ChatUpdateUpdateManyMutationInput, ChatUpdateUncheckedUpdateManyWithoutChatUpdatesInput>
  }

  export type ChatUpdateScalarWhereInput = {
    AND?: Enumerable<ChatUpdateScalarWhereInput>
    OR?: Enumerable<ChatUpdateScalarWhereInput>
    NOT?: Enumerable<ChatUpdateScalarWhereInput>
    eventId?: IntFilter | number
    type?: EnumChatUpdateTypeFilter | ChatUpdateType
    nameBefore?: StringNullableFilter | string | null
    nameAfter?: StringNullableFilter | string | null
    descriptionBefore?: StringNullableFilter | string | null
    descriptionAfter?: StringNullableFilter | string | null
    newRole?: EnumRoleNullableFilter | Role | null
  }

  export type UserUpsertWithoutMembersAddedToChatInput = {
    update: XOR<UserUpdateWithoutMembersAddedToChatInput, UserUncheckedUpdateWithoutMembersAddedToChatInput>
    create: XOR<UserCreateWithoutMembersAddedToChatInput, UserUncheckedCreateWithoutMembersAddedToChatInput>
  }

  export type UserUpdateWithoutMembersAddedToChatInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMembersAddedToChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUpsertWithoutMembersRemovedInput = {
    update: XOR<UserUpdateWithoutMembersRemovedInput, UserUncheckedUpdateWithoutMembersRemovedInput>
    create: XOR<UserCreateWithoutMembersRemovedInput, UserUncheckedCreateWithoutMembersRemovedInput>
  }

  export type UserUpdateWithoutMembersRemovedInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
  }

  export type UserUncheckedUpdateWithoutMembersRemovedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type UserCreateWithoutCreatorOfChatsInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutCreatorOfChatsInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutCreatorOfChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatorOfChatsInput, UserUncheckedCreateWithoutCreatorOfChatsInput>
  }

  export type MemberCreateWithoutChatInput = {
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMemberOfChatsInput
    chatUpdates?: ChatUpdateCreateNestedManyWithoutMembersInput
    addedBy: UserCreateNestedOneWithoutMembersAddedToChatInput
    removedBy?: UserCreateNestedOneWithoutMembersRemovedInput
  }

  export type MemberUncheckedCreateWithoutChatInput = {
    id?: number
    userId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
    chatUpdates?: ChatUpdateUncheckedCreateNestedManyWithoutMembersInput
  }

  export type MemberCreateOrConnectWithoutChatInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutChatInput, MemberUncheckedCreateWithoutChatInput>
  }

  export type MemberCreateManyChatInputEnvelope = {
    data: Enumerable<MemberCreateManyChatInput>
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutChatInput = {
    type: EventType
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    message?: MessageCreateNestedOneWithoutEventInput
    chatUpdate?: ChatUpdateCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutChatInput = {
    id?: number
    type: EventType
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    message?: MessageUncheckedCreateNestedOneWithoutEventInput
    chatUpdate?: ChatUpdateUncheckedCreateNestedOneWithoutEventInput
  }

  export type EventCreateOrConnectWithoutChatInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutChatInput, EventUncheckedCreateWithoutChatInput>
  }

  export type EventCreateManyChatInputEnvelope = {
    data: Enumerable<EventCreateManyChatInput>
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutChatInput = {
    type: AlertType
    createdAt?: Date | string
    recipients?: UserCreateNestedManyWithoutAlertsInput
    createdBy: UserCreateNestedOneWithoutAlertsSentInput
    request?: RequestCreateNestedOneWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutChatInput = {
    id?: number
    type: AlertType
    createdById: number
    createdAt?: Date | string
    requestId?: number | null
    recipients?: UserUncheckedCreateNestedManyWithoutAlertsInput
  }

  export type AlertCreateOrConnectWithoutChatInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutChatInput, AlertUncheckedCreateWithoutChatInput>
  }

  export type AlertCreateManyChatInputEnvelope = {
    data: Enumerable<AlertCreateManyChatInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatorOfChatsInput = {
    update: XOR<UserUpdateWithoutCreatorOfChatsInput, UserUncheckedUpdateWithoutCreatorOfChatsInput>
    create: XOR<UserCreateWithoutCreatorOfChatsInput, UserUncheckedCreateWithoutCreatorOfChatsInput>
  }

  export type UserUpdateWithoutCreatorOfChatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatorOfChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type MemberUpsertWithWhereUniqueWithoutChatInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutChatInput, MemberUncheckedUpdateWithoutChatInput>
    create: XOR<MemberCreateWithoutChatInput, MemberUncheckedCreateWithoutChatInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutChatInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutChatInput, MemberUncheckedUpdateWithoutChatInput>
  }

  export type MemberUpdateManyWithWhereWithoutChatInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMembersInput>
  }

  export type EventUpsertWithWhereUniqueWithoutChatInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutChatInput, EventUncheckedUpdateWithoutChatInput>
    create: XOR<EventCreateWithoutChatInput, EventUncheckedCreateWithoutChatInput>
  }

  export type EventUpdateWithWhereUniqueWithoutChatInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutChatInput, EventUncheckedUpdateWithoutChatInput>
  }

  export type EventUpdateManyWithWhereWithoutChatInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutEventInput>
  }

  export type AlertUpsertWithWhereUniqueWithoutChatInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutChatInput, AlertUncheckedUpdateWithoutChatInput>
    create: XOR<AlertCreateWithoutChatInput, AlertUncheckedCreateWithoutChatInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutChatInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutChatInput, AlertUncheckedUpdateWithoutChatInput>
  }

  export type AlertUpdateManyWithWhereWithoutChatInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutAlertsInput>
  }

  export type ChatCreateWithoutEventInput = {
    type: ChatType
    name?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatorOfChatsInput
    members?: MemberCreateNestedManyWithoutChatInput
    alerts?: AlertCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutEventInput = {
    id?: number
    type: ChatType
    name?: string | null
    description?: string | null
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    members?: MemberUncheckedCreateNestedManyWithoutChatInput
    alerts?: AlertUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutEventInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutEventInput, ChatUncheckedCreateWithoutEventInput>
  }

  export type UserCreateWithoutEventsCreatedInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutEventsCreatedInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    likedMessages?: MessageUncheckedCreateNestedManyWithoutLikedByInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutEventsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
  }

  export type MessageCreateWithoutEventInput = {
    content: string
    likedBy?: UserCreateNestedManyWithoutLikedMessagesInput
  }

  export type MessageUncheckedCreateWithoutEventInput = {
    content: string
    likedBy?: UserUncheckedCreateNestedManyWithoutLikedMessagesInput
  }

  export type MessageCreateOrConnectWithoutEventInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutEventInput, MessageUncheckedCreateWithoutEventInput>
  }

  export type ChatUpdateCreateWithoutEventInput = {
    type: ChatUpdateType
    nameBefore?: string | null
    nameAfter?: string | null
    descriptionBefore?: string | null
    descriptionAfter?: string | null
    newRole?: Role | null
    members?: MemberCreateNestedManyWithoutChatUpdatesInput
  }

  export type ChatUpdateUncheckedCreateWithoutEventInput = {
    type: ChatUpdateType
    nameBefore?: string | null
    nameAfter?: string | null
    descriptionBefore?: string | null
    descriptionAfter?: string | null
    newRole?: Role | null
    members?: MemberUncheckedCreateNestedManyWithoutChatUpdatesInput
  }

  export type ChatUpdateCreateOrConnectWithoutEventInput = {
    where: ChatUpdateWhereUniqueInput
    create: XOR<ChatUpdateCreateWithoutEventInput, ChatUpdateUncheckedCreateWithoutEventInput>
  }

  export type ChatUpsertWithoutEventInput = {
    update: XOR<ChatUpdateWithoutEventInput, ChatUncheckedUpdateWithoutEventInput>
    create: XOR<ChatCreateWithoutEventInput, ChatUncheckedCreateWithoutEventInput>
  }

  export type ChatUpdateWithoutEventInput = {
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatorOfChatsNestedInput
    members?: MemberUpdateManyWithoutChatNestedInput
    alerts?: AlertUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutChatNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutChatNestedInput
  }

  export type UserUpsertWithoutEventsCreatedInput = {
    update: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
  }

  export type UserUpdateWithoutEventsCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type MessageUpsertWithoutEventInput = {
    update: XOR<MessageUpdateWithoutEventInput, MessageUncheckedUpdateWithoutEventInput>
    create: XOR<MessageCreateWithoutEventInput, MessageUncheckedCreateWithoutEventInput>
  }

  export type MessageUpdateWithoutEventInput = {
    content?: StringFieldUpdateOperationsInput | string
    likedBy?: UserUpdateManyWithoutLikedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutEventInput = {
    content?: StringFieldUpdateOperationsInput | string
    likedBy?: UserUncheckedUpdateManyWithoutLikedMessagesNestedInput
  }

  export type ChatUpdateUpsertWithoutEventInput = {
    update: XOR<ChatUpdateUpdateWithoutEventInput, ChatUpdateUncheckedUpdateWithoutEventInput>
    create: XOR<ChatUpdateCreateWithoutEventInput, ChatUpdateUncheckedCreateWithoutEventInput>
  }

  export type ChatUpdateUpdateWithoutEventInput = {
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
    members?: MemberUpdateManyWithoutChatUpdatesNestedInput
  }

  export type ChatUpdateUncheckedUpdateWithoutEventInput = {
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
    members?: MemberUncheckedUpdateManyWithoutChatUpdatesNestedInput
  }

  export type EventCreateWithoutMessageInput = {
    type: EventType
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    chat: ChatCreateNestedOneWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    chatUpdate?: ChatUpdateCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutMessageInput = {
    id?: number
    type: EventType
    chatId: number
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    chatUpdate?: ChatUpdateUncheckedCreateNestedOneWithoutEventInput
  }

  export type EventCreateOrConnectWithoutMessageInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutMessageInput, EventUncheckedCreateWithoutMessageInput>
  }

  export type UserCreateWithoutLikedMessagesInput = {
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserCreateNestedManyWithoutFriendsInput
    creatorOfChats?: ChatCreateNestedManyWithoutCreatedByInput
    alerts?: AlertCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertCreateNestedManyWithoutCreatedByInput
    requests?: RequestCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberCreateNestedManyWithoutRemovedByInput
  }

  export type UserUncheckedCreateWithoutLikedMessagesInput = {
    id?: number
    email: string
    name?: string | null
    username: string
    updatedAt?: Date | string
    createdAt?: Date | string
    friends?: UserUncheckedCreateNestedManyWithoutFriendsOfInput
    friendsOf?: UserUncheckedCreateNestedManyWithoutFriendsInput
    creatorOfChats?: ChatUncheckedCreateNestedManyWithoutCreatedByInput
    alerts?: AlertUncheckedCreateNestedManyWithoutRecipientsInput
    alertsSent?: AlertUncheckedCreateNestedManyWithoutCreatedByInput
    requests?: RequestUncheckedCreateNestedManyWithoutRecipientInput
    requestsSent?: RequestUncheckedCreateNestedManyWithoutCreatedByInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatedByInput
    memberOfChats?: MemberUncheckedCreateNestedManyWithoutUserInput
    membersAddedToChat?: MemberUncheckedCreateNestedManyWithoutAddedByInput
    membersRemoved?: MemberUncheckedCreateNestedManyWithoutRemovedByInput
  }

  export type UserCreateOrConnectWithoutLikedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedMessagesInput, UserUncheckedCreateWithoutLikedMessagesInput>
  }

  export type EventUpsertWithoutMessageInput = {
    update: XOR<EventUpdateWithoutMessageInput, EventUncheckedUpdateWithoutMessageInput>
    create: XOR<EventCreateWithoutMessageInput, EventUncheckedCreateWithoutMessageInput>
  }

  export type EventUpdateWithoutMessageInput = {
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chat?: ChatUpdateOneRequiredWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    chatUpdate?: ChatUpdateUpdateOneWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    chatId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatUpdate?: ChatUpdateUncheckedUpdateOneWithoutEventNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutLikedMessagesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLikedMessagesInput, UserUncheckedUpdateWithoutLikedMessagesInput>
    create: XOR<UserCreateWithoutLikedMessagesInput, UserUncheckedCreateWithoutLikedMessagesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLikedMessagesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLikedMessagesInput, UserUncheckedUpdateWithoutLikedMessagesInput>
  }

  export type UserUpdateManyWithWhereWithoutLikedMessagesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLikedByInput>
  }

  export type EventCreateWithoutChatUpdateInput = {
    type: EventType
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    chat: ChatCreateNestedOneWithoutEventInput
    createdBy: UserCreateNestedOneWithoutEventsCreatedInput
    message?: MessageCreateNestedOneWithoutEventInput
  }

  export type EventUncheckedCreateWithoutChatUpdateInput = {
    id?: number
    type: EventType
    chatId: number
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
    message?: MessageUncheckedCreateNestedOneWithoutEventInput
  }

  export type EventCreateOrConnectWithoutChatUpdateInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutChatUpdateInput, EventUncheckedCreateWithoutChatUpdateInput>
  }

  export type MemberCreateWithoutChatUpdatesInput = {
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMemberOfChatsInput
    chat: ChatCreateNestedOneWithoutMembersInput
    addedBy: UserCreateNestedOneWithoutMembersAddedToChatInput
    removedBy?: UserCreateNestedOneWithoutMembersRemovedInput
  }

  export type MemberUncheckedCreateWithoutChatUpdatesInput = {
    id?: number
    userId: number
    chatId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
  }

  export type MemberCreateOrConnectWithoutChatUpdatesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutChatUpdatesInput, MemberUncheckedCreateWithoutChatUpdatesInput>
  }

  export type EventUpsertWithoutChatUpdateInput = {
    update: XOR<EventUpdateWithoutChatUpdateInput, EventUncheckedUpdateWithoutChatUpdateInput>
    create: XOR<EventCreateWithoutChatUpdateInput, EventUncheckedCreateWithoutChatUpdateInput>
  }

  export type EventUpdateWithoutChatUpdateInput = {
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chat?: ChatUpdateOneRequiredWithoutEventNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    message?: MessageUpdateOneWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutChatUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    chatId?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUncheckedUpdateOneWithoutEventNestedInput
  }

  export type MemberUpsertWithWhereUniqueWithoutChatUpdatesInput = {
    where: MemberWhereUniqueInput
    update: XOR<MemberUpdateWithoutChatUpdatesInput, MemberUncheckedUpdateWithoutChatUpdatesInput>
    create: XOR<MemberCreateWithoutChatUpdatesInput, MemberUncheckedCreateWithoutChatUpdatesInput>
  }

  export type MemberUpdateWithWhereUniqueWithoutChatUpdatesInput = {
    where: MemberWhereUniqueInput
    data: XOR<MemberUpdateWithoutChatUpdatesInput, MemberUncheckedUpdateWithoutChatUpdatesInput>
  }

  export type MemberUpdateManyWithWhereWithoutChatUpdatesInput = {
    where: MemberScalarWhereInput
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyWithoutMembersInput>
  }

  export type ChatCreateManyCreatedByInput = {
    id?: number
    type: ChatType
    name?: string | null
    description?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AlertCreateManyCreatedByInput = {
    id?: number
    type: AlertType
    createdAt?: Date | string
    chatId?: number | null
    requestId?: number | null
  }

  export type RequestCreateManyRecipientInput = {
    id?: number
    type: RequestType
    state?: RequestState
    createdById: number
    createdAt?: Date | string
  }

  export type RequestCreateManyCreatedByInput = {
    id?: number
    type: RequestType
    state?: RequestState
    recipientId: number
    createdAt?: Date | string
  }

  export type EventCreateManyCreatedByInput = {
    id?: number
    type: EventType
    chatId: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MemberCreateManyUserInput = {
    id?: number
    chatId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
  }

  export type MemberCreateManyAddedByInput = {
    id?: number
    userId: number
    chatId: number
    role?: Role
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
  }

  export type MemberCreateManyRemovedByInput = {
    id?: number
    userId: number
    chatId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
  }

  export type UserUpdateWithoutFriendsOfInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendsOfInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutFriendsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutFriendsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFriendsOfInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutLikedByInput = {
    content?: StringFieldUpdateOperationsInput | string
    event?: EventUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutLikedByInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutLikedMessagesInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUpdateWithoutCreatedByInput = {
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUpdateManyWithoutChatNestedInput
    event?: EventUpdateManyWithoutChatNestedInput
    alerts?: AlertUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    members?: MemberUncheckedUpdateManyWithoutChatNestedInput
    event?: EventUncheckedUpdateManyWithoutChatNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutCreatorOfChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumChatTypeFieldUpdateOperationsInput | ChatType
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUpdateWithoutRecipientsInput = {
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutAlertsSentNestedInput
    chat?: ChatUpdateOneWithoutAlertsNestedInput
    request?: RequestUpdateOneWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutRecipientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: NullableIntFieldUpdateOperationsInput | number | null
    requestId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlertUncheckedUpdateManyWithoutAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: NullableIntFieldUpdateOperationsInput | number | null
    requestId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlertUpdateWithoutCreatedByInput = {
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUpdateManyWithoutAlertsNestedInput
    chat?: ChatUpdateOneWithoutAlertsNestedInput
    request?: RequestUpdateOneWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: NullableIntFieldUpdateOperationsInput | number | null
    requestId?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: UserUncheckedUpdateManyWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutAlertsSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatId?: NullableIntFieldUpdateOperationsInput | number | null
    requestId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RequestUpdateWithoutRecipientInput = {
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutRequestsSentNestedInput
    alert?: AlertUpdateOneWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUncheckedUpdateOneWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateManyWithoutRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUpdateWithoutCreatedByInput = {
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutRequestsNestedInput
    alert?: AlertUpdateOneWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    recipientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUncheckedUpdateOneWithoutRequestNestedInput
  }

  export type RequestUncheckedUpdateManyWithoutRequestsSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumRequestTypeFieldUpdateOperationsInput | RequestType
    state?: EnumRequestStateFieldUpdateOperationsInput | RequestState
    recipientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutCreatedByInput = {
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chat?: ChatUpdateOneRequiredWithoutEventNestedInput
    message?: MessageUpdateOneWithoutEventNestedInput
    chatUpdate?: ChatUpdateUpdateOneWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    chatId?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUncheckedUpdateOneWithoutEventNestedInput
    chatUpdate?: ChatUpdateUncheckedUpdateOneWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutEventsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    chatId?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MemberUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    chatUpdates?: ChatUpdateUpdateManyWithoutMembersNestedInput
    addedBy?: UserUpdateOneRequiredWithoutMembersAddedToChatNestedInput
    removedBy?: UserUpdateOneWithoutMembersRemovedNestedInput
  }

  export type MemberUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
    chatUpdates?: ChatUpdateUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMemberOfChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MemberUpdateWithoutAddedByInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMemberOfChatsNestedInput
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    chatUpdates?: ChatUpdateUpdateManyWithoutMembersNestedInput
    removedBy?: UserUpdateOneWithoutMembersRemovedNestedInput
  }

  export type MemberUncheckedUpdateWithoutAddedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
    chatUpdates?: ChatUpdateUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMembersAddedToChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MemberUpdateWithoutRemovedByInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMemberOfChatsNestedInput
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    chatUpdates?: ChatUpdateUpdateManyWithoutMembersNestedInput
    addedBy?: UserUpdateOneRequiredWithoutMembersAddedToChatNestedInput
  }

  export type MemberUncheckedUpdateWithoutRemovedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatUpdates?: ChatUpdateUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMembersRemovedInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutAlertsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    likedMessages?: MessageUncheckedUpdateManyWithoutLikedByNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRecipientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateUpdateWithoutMembersInput = {
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
    event?: EventUpdateOneRequiredWithoutChatUpdateNestedInput
  }

  export type ChatUpdateUncheckedUpdateWithoutMembersInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
  }

  export type ChatUpdateUncheckedUpdateManyWithoutChatUpdatesInput = {
    eventId?: IntFieldUpdateOperationsInput | number
    type?: EnumChatUpdateTypeFieldUpdateOperationsInput | ChatUpdateType
    nameBefore?: NullableStringFieldUpdateOperationsInput | string | null
    nameAfter?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionBefore?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionAfter?: NullableStringFieldUpdateOperationsInput | string | null
    newRole?: NullableEnumRoleFieldUpdateOperationsInput | Role | null
  }

  export type MemberCreateManyChatInput = {
    id?: number
    userId: number
    role?: Role
    addedById: number
    createdAt?: Date | string
    removedAt?: Date | string | null
    removedById?: number | null
  }

  export type EventCreateManyChatInput = {
    id?: number
    type: EventType
    createdById: number
    updatedAt?: Date | string
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AlertCreateManyChatInput = {
    id?: number
    type: AlertType
    createdById: number
    createdAt?: Date | string
    requestId?: number | null
  }

  export type MemberUpdateWithoutChatInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMemberOfChatsNestedInput
    chatUpdates?: ChatUpdateUpdateManyWithoutMembersNestedInput
    addedBy?: UserUpdateOneRequiredWithoutMembersAddedToChatNestedInput
    removedBy?: UserUpdateOneWithoutMembersRemovedNestedInput
  }

  export type MemberUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
    chatUpdates?: ChatUpdateUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type MemberUncheckedUpdateManyWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EventUpdateWithoutChatInput = {
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutEventsCreatedNestedInput
    message?: MessageUpdateOneWithoutEventNestedInput
    chatUpdate?: ChatUpdateUpdateOneWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUncheckedUpdateOneWithoutEventNestedInput
    chatUpdate?: ChatUpdateUncheckedUpdateOneWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumEventTypeFieldUpdateOperationsInput | EventType
    createdById?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUpdateWithoutChatInput = {
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUpdateManyWithoutAlertsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAlertsSentNestedInput
    request?: RequestUpdateOneWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutChatInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumAlertTypeFieldUpdateOperationsInput | AlertType
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestId?: NullableIntFieldUpdateOperationsInput | number | null
    recipients?: UserUncheckedUpdateManyWithoutAlertsNestedInput
  }

  export type UserUpdateWithoutLikedMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUpdateManyWithoutFriendsNestedInput
    creatorOfChats?: ChatUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    friends?: UserUncheckedUpdateManyWithoutFriendsOfNestedInput
    friendsOf?: UserUncheckedUpdateManyWithoutFriendsNestedInput
    creatorOfChats?: ChatUncheckedUpdateManyWithoutCreatedByNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutRecipientsNestedInput
    alertsSent?: AlertUncheckedUpdateManyWithoutCreatedByNestedInput
    requests?: RequestUncheckedUpdateManyWithoutRecipientNestedInput
    requestsSent?: RequestUncheckedUpdateManyWithoutCreatedByNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatedByNestedInput
    memberOfChats?: MemberUncheckedUpdateManyWithoutUserNestedInput
    membersAddedToChat?: MemberUncheckedUpdateManyWithoutAddedByNestedInput
    membersRemoved?: MemberUncheckedUpdateManyWithoutRemovedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLikedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUpdateWithoutChatUpdatesInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMemberOfChatsNestedInput
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    addedBy?: UserUpdateOneRequiredWithoutMembersAddedToChatNestedInput
    removedBy?: UserUpdateOneWithoutMembersRemovedNestedInput
  }

  export type MemberUncheckedUpdateWithoutChatUpdatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chatId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
    addedById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    removedById?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}